[{"content":"","date":null,"permalink":"/","section":"Home","summary":"","title":"Home"},{"content":" Windows made by Windows! Check out Nui Engine on Github Now that I have a logging and assertion framework up and running. The next thing I want to add is an application window. For this I will be using the Win32 API and no external libraries. Here is what I want my window class to support:\nSimple styling Custom title text Self contained message pump Message routing (with callbacks) Window Styling # I will be supporting 4 different window styles\nWindowed Windowed Fullscreem Borderless Borderless Fullscreem These are the high level styles which are exposed to the end user. They map to an internal style enum class which enables certain styles (like window drop shadows).\n// User facing styles (part of Window class) enum class Style { Windowed, Windowed Fullscreem, Borderless, Borderless Fullscreem } In the .cpp file, hidden from the end user there is an internal style enum:\nenum StyleInternal : DWORD { Windowed = WS_OVERLAPPEDWINDOW | WS_THICKFRAME | WS_CAPTION | WS_SYSMENU | WS_MINIMIZEBOX | WS_MAXIMIZEBOX, WindowedFullscreen = Windowed | WS_MAXIMIZE, AeroBorderless = WS_POPUP | /*WS_THICKFRAME |*/ WS_CAPTION | WS_SYSMENU | WS_MAXIMIZEBOX | WS_MINIMIZEBOX, BasicBorderless = WS_POPUP | /*WS_THICKFRAME |*/ WS_SYSMENU | WS_MAXIMIZEBOX | WS_MINIMIZEBOX, BorderlessFullscreen = WS_MAXIMIZE }; // Borderless styles have no WS_THICKFRAME to disable window resizing (we will handle that manually later) WHen making my window I use a style proxy which strips fullscreen inforamtion from the style. Allowing me to then convert the new style to an internal window style and manually fullscreen the window if needed.\n// Returns a stripped window style and tells if the style contained fullscreen flag Window::Style GetStyleProxy(Window::Style style, bool\u0026amp; outIsFullscreen) { Window::Style styleProxy = style; outIsFullscreen = false; if (styleProxy == Window::Style::WindowedFullscreen) { outIsFullscreen = true; styleProxy = Window::Style::Windowed; } else if (styleProxy == Window::Style::BorderlessFullscreen) { outIsFullscreen = true; styleProxy = Window::Style::Borderless; } return style; } Now that I have our proxy style, I need to convert this to the internal style and this is done using these three functions:\nbool IsCompositionEnabled() { BOOL compositionEnabled = FALSE; bool success = ::DwmIsCompositionEnabled(\u0026amp;compositionEnabled) == S_OK; return compositionEnabled \u0026amp;\u0026amp; success; } StyleInternal GetBorderlessStyle() { return IsCompositionEnabled() ? StyleInternal::AeroBorderless : StyleInternal::BasicBorderless; } StyleInternal ConvertStyle(Window::Style style) { switch (style) { case Window::Style::Windowed: return StyleInternal::Windowed; case Window::Style::WindowedFullscreen: return StyleInternal::WindowedFullscreen; case Window::Style::Borderless: case Window::Style::BorderlessFullscreen: return GetBorderlessStyle(); } return StyleInternal::Windowed; } AeroBorderless are the new types of windows which have Desktop Window Manager Composition toggled (available after Windows 8). Making all Borderless windows AeroBordless by default. Becuase of this some extra work will have to be done to handle window resizing (assuming WS_THICKFRAME is enabled).\nOne could say that I can simply use enums (instead of enum classes) and bit mask flags instead of doing all these unecessary conversions. And you are probably right. But I wrote this code at 4 AM, heavily sleep deprived. And sleepy me thought this was a great idea and I stuck with it. Now its too late to go back and to be honest I am kinda proud of this mess XD.\nThe Window Class # Now that I have the window styling logic out of the way. I can start creating the window itself. Starting with the constructor and the destructor\nstatic const StringW s_windowClassName = L\u0026#34;NuiApp\u0026#34;; Window::Window(Window::Style style, StringViewW title, Window::Size size) : m_style(style) // Window::Style , m_title(title) // Wide string for window title , m_size(size) // Structure containing sizeX and sizeY , m_hWnd(nullptr) // Window handle , m_isFocused(false) // Bool to check if window has focus , m_hInstance(GetModuleHandle(NULL)) // Application instance handle { MakeWindow(); } Window::~Window() { ::DestroyWindow(m_hWnd); ::UnregisterClass(s_windowClassName.c_str(), m_hInstance); } The constructor calls the MakeWindow function which handles window creation which contains the following steps.\nRegistering Window Class # The first step to creating a Win32 window is to register a window class. You can have multiple (actual) windows part of a window class.\nHere I register a window class, where:\nThe window redraw\u0026rsquo;s if the width or height changes (see window class styles) The window uses a static Windows Procedure (explained later) The background is white The cursor is the default cursor The class is then registered using the RegisterClassExW function. This may fail is the class is already registered (which is not a problem), so I simply log that as an error and try to continue. If this was a breaking failure, then the next function where I create a window will fail whose error code will correspond to the window class registeration,\n// Register window class WNDCLASSEXW wcx{}; wcx.cbSize = sizeof(wcx); wcx.style = CS_HREDRAW | CS_VREDRAW; wcx.hInstance = m_hInstance; wcx.lpfnWndProc = WndProc; wcx.lpszClassName = s_windowClassName.c_str(); wcx.hbrBackground = reinterpret_cast\u0026lt;HBRUSH\u0026gt;(COLOR_WINDOW + 1); wcx.hCursor = ::LoadCursorW(nullptr, IDC_ARROW); if (!::RegisterClassExW(\u0026amp;wcx)) { // Log error but try to continue regardless NUI_LOG(Error, Window, \u0026#34;Failed to register window class. \u0026#34;, GetWin32ErrorString(GetLastError())); } Centring The Window # This is a completely optional step. I like all muy windows to be created at the centre of the screen.\nUsing the Win32 API to get the desktop window rect. Then using that RECT to calculate the x and y coordinates to place my window (based on the provided window size).\nRECT desktopRect; ::GetWindowRect(::GetDesktopWindow(), \u0026amp;desktopRect); I32 posX = (desktopRect.right / 2) - (m_size.X / 2); I32 posY = (desktopRect.bottom / 2) - (m_size.Y / 2); Creating The Window # This is the part where the window is actually created. Again using the Win32 API.\nStyleInternal style = ConvertStyle(m_style); m_hWnd = ::CreateWindowExW( 0, // No extended styles s_windowClassName.c_str(), // Registered WNDCLASSEXW name m_title.c_str(), // Title of the window style, // Converted internal style posX, posY, // Position of the window m_size.X, m_size.Y, // Size of the window nullptr, // No parent nullptr, // No menu m_hInstance, // Application instance this // LPARAM ); NUI_ASSERT(m_hWnd, \u0026#34;Failed to create window, handle is nullptr\u0026#34;); Here I pass this as the LPARAM, since I will later be using that to route the window messages to the class memer functions\nApplying Styling # Now that I have the window finally created, it is time to apply the styling I have ranting about from the start.\n// Get style proxy (we will be using this to apply styles) bool fullscreen = false; Style styleProxy = GetStyleProxy(m_style, fullscreen); // We are modifying the style only if the window style is borderless if (HasStyleFlag((DWORD)styleProxy, (DWORD)Style::Borderless)) { StyleInternal style = ConvertStyle(styleProxy); StyleInternal oldStyle = static_cast\u0026lt;StyleInternal\u0026gt;(::GetWindowLongW(m_hWnd, GWL_STYLE)); if (style != oldStyle) { // Set the new style ::SetWindowLongW(m_hWnd, GWL_STYLE, static_cast\u0026lt;LONG\u0026gt;(style)); // Extend frame for resizing (AeroBorderless style) if (IsCompositionEnabled()) { static const MARGINS shadowState[2]{ { 0, 0, 0, 0 }, { 1, 1, 1, 1 } }; ::DwmExtendFrameIntoClientArea(m_hWnd, \u0026amp;shadowState[style != StyleInternal::Windowed]); } // Redraw frame ::SetWindowPos(m_hWnd, nullptr, 0, 0, 0, 0, SWP_FRAMECHANGED | SWP_NOMOVE | SWP_NOSIZE); } } // Show window normal or fullscreen ::ShowWindow(m_hWnd, fullscreen ? SW_MAXIMIZE : SW_SHOWNORMAL); // Update window size RECT rect{}; AdjustWindowRect(\u0026amp;rect, (DWORD)m_style, FALSE); m_size.X = rect.right - rect.left; m_size.Y = rect.bottom - rect.top; Window Message Pump # Windows based applications are event-driven. These events are passed into the windows procedure call after they have been processed by the windows message pump.\nI don\u0026rsquo;t want the engine/external code to deal with the windows message loop. So I made a function called WantsToClose\nbool Window::WantsToClose() const { // Windows message pump MSG msg; while (::PeekMessage(\u0026amp;msg, NULL, 0, 0, PM_REMOVE)) { ::TranslateMessage(\u0026amp;msg); ::DispatchMessageW(\u0026amp;msg); if (msg.message == WM_QUIT) { return true; } } return false; } This can be used like this. Here I check if the window wants to close (this runs the message pump and dispatches all the events which can be handled manually).\nwhile (!window-\u0026gt;WantsToClose()) { now = timer.GetElapsedSeconds(); // Perform update code here dt = now - elapsed; elapsed = now; } This is very similar to the actual code being used in the engine to update the application and the window.\nWindow Procedure # When creating the WNDCLASSEXW I passed in the WndProc as my window procedure function. This is a static member method that like an interface for calling the private MessageRouter function.\nWhen the event NCCREATE (sent prior WM_CREATE when a window is first created) is sent. I extract the this pointer we passed at the LPARAM when creating the window. Then reinterpret the pointer as this window class and set that as the Window Long Pointer. Later, I try to retrieve the long pointer. If succeeded, that means we have our window, on which I call the MessageRouter else call the DefWndProc\nLRESULT WINAPI Window::WndProc(HWND hWnd, UINT uMsg, WPARAM wParam, LPARAM lParam) { switch (uMsg) { case WM_NCCREATE: { LPCREATESTRUCT pCreateStruct = reinterpret_cast\u0026lt;LPCREATESTRUCT\u0026gt;(lParam); Window* pObj = reinterpret_cast\u0026lt;Window*\u0026gt;(pCreateStruct-\u0026gt;lpCreateParams); ::SetWindowLongPtr(hWnd, GWLP_USERDATA, reinterpret_cast\u0026lt;LONG_PTR\u0026gt;(pCreateStruct-\u0026gt;lpCreateParams)); return ::DefWindowProc(hWnd, uMsg, wParam, lParam); } } Window* pObj = reinterpret_cast\u0026lt;Window*\u0026gt;(::GetWindowLongPtr(hWnd, GWLP_USERDATA)); if (pObj) return pObj-\u0026gt;MessageRouter(hWnd, uMsg, wParam, lParam); else return ::DefWindowProc(hWnd, uMsg, wParam, lParam); } Message Router # This the first layer of message indirection where I expose a bit of the low level API to the end user. In my Window class header file have the following defines.\n#define NUI_WNDPROC_ARGS Nui::Window*, UINT, WPARAM, LPARAM #define NUI_WNDPROC_NAMED_ARGS Nui::Window* window, UINT uMsg, WPARAM wParam, LPARAM lParam using WndCallback = std::function\u0026lt;LRESULT(NUI_WNDPROC_ARGS)\u0026gt;; Using that type alias, I have a member map where I can call any message the user wants to interject.\n/** * @brief Window message callbacks * @note The key is the message * @note The value is the callback * @note The callback will be called when the message is received in the MessageRouter */ std::map\u0026lt;U32, WndCallback\u0026gt; m_callbacks; This is how the router function works. It checks if the window message is present in the map and calls the user bound std::function\u0026lt;WndCallback\u0026gt; else calls the actual private member method, the MessageHandler.\nLRESULT Window::MessageRouter(HWND hWnd, UINT uMsg, WPARAM wParam, LPARAM lParam) { if (m_callbacks.contains(uMsg)) { return m_callbacks[uMsg](this, uMsg, wParam, lParam); } else { return MessageHandler(hWnd, uMsg, wParam, lParam); } } Message Handler # Finally this is the final function where a Win32 event will arrive to before either being processed internally, dispatched to another system (such as input messages) or be sent to the the default windows procedure call (because we don\u0026rsquo;t care about it).\nLRESULT Window::MessageHandler(HWND hWnd, UINT uMsg, WPARAM wParam, LPARAM lParam) { switch (uMsg) { case WM_NCCALCSIZE: { if (wParam == TRUE \u0026amp;\u0026amp; HasStyleFlag((DWORD)m_style, (DWORD)Style::Borderless)) { auto\u0026amp; params = *reinterpret_cast\u0026lt;NCCALCSIZE_PARAMS*\u0026gt;(lParam); AdjustMaximizedClientRect(params.rgrc[0]); return 0; } break; } case WM_NCHITTEST: { // When we have no border or title bar, we need to perform our // own hit testing to allow resizing and moving. if (HasStyleFlag((DWORD)m_style, (DWORD)Style::Borderless)) { return HitTest(POINT{ GET_X_LPARAM(lParam), GET_Y_LPARAM(lParam) }); } break; } case WM_DESTROY: { ::PostQuitMessage(0); return 0; } case WM_CLOSE: { DestroyWindow(hWnd); return 0; } case WM_SETFOCUS: { m_isFocused = true; return 0; } case WM_KILLFOCUS: { m_isFocused = false; return 0; } return ::DefWindowProc(hWnd, uMsg, wParam, lParam); } In the above function I handle the following messages\nWM_NCCALCSIZE Sent when the size and position of a window\u0026rsquo;s client area must be calculated. Allows me to control the size and area of the the client WM_NCHITTEST Sent in order to determine what part of the window corresponds to a particular screen coordinate Allows me to manually control check for hit test when resizing a bordeless window (when WS_THICKFRAME is enabled) WM_DESTROY Sent when the window is destroyed I use this to trigger the close of the application WM_CLOSE Sent when the close button or Alt+F3 is pressed I use this to destroy the window, causing WM_DESTROY to be sent WM_SETFOCUS/WM_KILLFOCUS Sent when the window gains or loses input focus Use this to check if the window is currently focused, will be usefull when designing the input system Manual Hit Testing # Here is the function that I call whenever the WM_NCHITTEST is sent\nLRESULT Window::HitTest(POINT cursor) { // Identify borders and corners to allow resizing the window. // Note: On Windows 10, windows behave differently and // allow resizing outside the visible window frame. // This implementation does not replicate that behavior. const POINT border { ::GetSystemMetrics(SM_CXFRAME) + ::GetSystemMetrics(SM_CXPADDEDBORDER), ::GetSystemMetrics(SM_CYFRAME) + ::GetSystemMetrics(SM_CXPADDEDBORDER) }; RECT window; if (!::GetWindowRect(m_hWnd, \u0026amp;window)) { return HTNOWHERE; } enum region_mask { client = 0b0000, left = 0b0001, right = 0b0010, top = 0b0100, bottom = 0b1000, }; const auto result = left * (cursor.x \u0026lt; (window.left + border.x)) | right * (cursor.x \u0026gt;= (window.right - border.x)) | top * (cursor.y \u0026lt; (window.top + border.y)) | bottom * (cursor.y \u0026gt;= (window.bottom - border.y)); // Return where the mouse hit test switch (result) { case left : return HTLEFT; case right : return HTRIGHT; case top : return HTTOP; case bottom : return HTBOTTOM; case top | left : return HTTOPLEFT; case top | right : return HTTOPRIGHT; case bottom | left : return HTBOTTOMLEFT; case bottom | right: return HTBOTTOMRIGHT; case client : return HTCLIENT; default : return HTNOWHERE; } } Conclusion # And finally with all that work, we finally have a window. Although one can simply get away with registering a window class and setting the window style to WS_OVERLAPPEDWINDOW along with performing proper message routing (with the message pump). I decided to go ahead and implement a alightly fancier windowing system. Which may or may not be too complex / over the top for basic needs.\nBut I am glad you stuck around till the end of the article. This was a long one. In the next one we will look at using the message routing system to create an Input System. Which will allow read keyboard and mouse inputs. See you in the next one! 👋\nProgramming Game Engine C++ ","date":null,"permalink":"/posts/mage4/","section":"Posts","summary":"Making a game engine - Part 4 - Windowing","title":"MAGE - Part 4"},{"content":" Throw it - Catch it - Log it Check out Nui Engine on Github With the project files now generated, we can start writing engine code. Every game engine needs a logging and error catching framework. Here is how I designed one for Nui Engine (with pseudocode).\nLogging # Log Levels # Every log message will have a verbosity level. Which is defined using an enumeration.\nenum class LogLevel { Debug, // For low level engine information Info, // For general information Warn, // For warnings Error, // For errors Fatal, // Similar to \u0026#39;Error\u0026#39;, also gives a stacktrace Exception // Similar to \u0026#39;Error\u0026#39;, also gives a stacktrace and crashes the program } LogEntry # Each log message will be wrapped in a LogEntry structure which contains additional information regarding the log message.\nstruct LogEntry { LogLevel Level; // Log level of the message String Category; // Log category of the message String Message; // The log message to display TimePoint Time; // Time point of log message Stacktrace Stacktrace; // The stacktrace to the location of log message } Since I am using C++23 for this project I have access to std::stacktrace which is what I am using to generate my stacktrace. There is also a header only stacktrace library called backward-cpp which contains a bunch of additional features. Although I did not use it here since I want the engine to have minimal external dependencies.\nLog File # Since I plan to use this engine with Visual Studio, I am going to use the VS Output Window as my log message output window. I will also be using a log file in case someone is not using Visual Studio (presently external debggers already hook into the OutputDebugString function using which the log message can also be viewed in the debuggers output window).\nI also created an internal structure called a LogFile which can be opened and closed using helper functions. To which the same formatted log message can be appended.\nThe log file resides in the \u0026lt;WorkingDir\u0026gt;/Saved/NuiEngine.log\nPrinting the Log # To print the log I have a function called Log which takes a LogEntry and formats it and prints it out.\nvoid Nui::Log(const LogEntry\u0026amp; entry) { // Make formatted log message from entry // Append time, category and verbosity with the message String formattedMsg = ... ; // Redirects string to output window and file (if opened) LogOut(formattedMsg); if (entry.Level == LogLevel::Fatal) { // Format and print the stacktrace to the output window/file PrintStacktrace(entry.Stacktrace); } } Although I do not want the user to directly use this function or create a LogEntry manually everytime they want to log something. So I made a wrapper macro.\n// The LogEntry constructor default initializes the stacktrace from this point #define NUI_LOG(Level, Category, Message) Nui::Log::Log(Nui::Log::LogEntry(Nui::Log::LogLevel::Level, #Category, Message)) Here is how the log message looks like in debug build (I have an extension called VSColorOutput enabled which highlights my output messages).\nLog test output in VS output window Assertions # Instead of using the default assert provided by C++. I wanted to make my own assert that makes use of LogLevel::Exception.\nI made a the following Assert function\nvoid Assert(bool condition, StringView conditionString, StringView message, StringView file, I32 line, Stacktrace trace) { if (!condition) { // Build a log message using the condition string and message String logMsg = ... ; // Create a log entry with level set to exception Log(LogEntry(LogLevel::Exception, ...)); // Manually print the trace PrintStackTrace(trace); // Crash the program throw std::runtime_error(\u0026#34;Assertion failed!\u0026#34;); } } Assertions in Nui are meant to be used using this macro\n#if NUI_DEBUG #define NUI_ASSERT(Condition, Message) Nui::Log::Assert(Condition, #Condition, Message, __FILE__, __LINE__) #else #define NUI_ASSERT(Condition, Message) #endif Here you can see the output window with the formatted message when an assertion fails, along with the stacktrace and file/line.\nOutput window when an assertion fails Conclusion # I would like to add the ability to set the log verbosity level. But at the time of development, I\u0026rsquo;d rather have all the log message printed so this is something we can come back to in the future. I\u0026rsquo;d also want to make the logging system multithreaded.\nOnce I have some Win32 specific functionality added in, I\u0026rsquo;d also like to show a message box when the program fails an assert in release mode such that the end user doesn\u0026rsquo;t have to go through the created log file to find out why the program crashed.\nAs usual the complete source code for this project is available on my GitHub repository (see top of page). If you want to see the documented implementation details.\nProgramming Game Engine C++ ","date":null,"permalink":"/posts/mage3/","section":"Posts","summary":"Making a game engine - Part 3 - Logging and Assertions","title":"MAGE - Part 3"},{"content":" First there was project architecture then there was directory structure Check out Nui Engine on Github The Process # Since this is an editor-less game engine. We need to plan how the user\u0026rsquo;s game (project) is integrated with the engine/project solution. Here is the proposed usage pipeline:\nClone/Fork the Github repository Run a script to generate project build scripts Generate project files Open Visual Studio solution with engine and user game code projects linked! The Build System # Since I am only developing this project for the Windows OS, I plan to use Visual Studio as my IDE and therefore MSVC as my C++ compiler. But to generate the solution and add the user project files I will be using Premake as my solution generator/build system.\nProject Folder Structure # When the user clones the repository, they should see the following folder structure\nNuiEngine (Root)/ ├─ Docs/ │ ├─ Doxygen generated docs ├─ Build/ │ ├─ Intermediate/ │ ├─ \u0026lt;BUILD_CONFIG\u0026gt;/ │ │ ├─ NuiCore/ │ │ ├─ NuiTest/ │ │ ├─ NuiConsole/ │ │ ├─ NuiGraphics/ │ │ ├─ NuiAudio/ │ │ ├─ \u0026lt;USER_PROJECT_NAME\u0026gt;/ │ │ │ ├─ Saved/ │ │ │ │ ├─ NuiEngine.log │ │ │ ├─ \u0026lt;USER_PROJECT_NAME\u0026gt;.exe ├─ Scripts/ │ ├─ Templates/ │ │ ├─ PremakeProjectTemplate.lua │ │ ├─ PremakeSolutionTemplate.lua │ ├─ premake5.exe │ ├─ CreateProject.py ├─ Engine/ │ ├─ Core/ │ │ ├─ BuildCore.lua │ ├─ Graphics/ │ │ ├─ BuildGraphics.lua │ ├─ Audio/ │ │ ├─ BuildAudio.lua │ ├─ Console/ │ │ ├─ BuildConsole.lua │ ├─ Test/ │ │ ├─ BuildTest.lua ├─ \u0026lt;USER_PROJECT_NAME\u0026gt;/ │ ├─ \u0026lt;USER_PROJECT_NAME\u0026gt;/ │ │ ├─ Game code... │ ├─ Main.cpp │ ├─ Build\u0026lt;USER_PROJECT_NAME\u0026gt;.lua ├─ GenerateProjectFiles.bat Initially there will be no Build and User Project folder. That will be generated using the Scripts/CreateProject.py script. All engine modules will be the in the Engine folder with their respective Premake Lua build files. These will be defined manually and will not change during project generation. I also include the premake5.exe with the repository.\nIn the Scripts folder there are also premake template files for the solution and user project that the python script will use when creating a project.\nCreating a New Project # To create a new project the user will have to run Scripts/CreateProject.py with the project name as the command line argument. The goal is to run this script only once when the project has to be created for the first time.\nUsing Python # I decided to use python since it\u0026rsquo;s super easy to easy to write and can be executed on the fly. This is what the Python script does:\nTakes the user project name as an command line argument Usage (cmd): CreateProject.py -projectname=\u0026lt;USER_PROJECT_NAME\u0026gt; Creates project directory in the root folder Creates the Build\u0026lt;USER_PROJECT_NAME\u0026gt;.lua using the PremakeProjectTemplate.lua file in the project directory Creates a sub folder in the project directory with the same name as the project. This is where the user code will be written. Calls premake5.exe to generate the Visual Studio solution and project files Generating Project Files # There is also a batch script in the root folder called GenerateProjectFiles.bat. Which invokes premake5.exe and can be used to update the project and solution when new files are added.\nWith this system I can also create GitHub actions to run the tests automatically.\nWith all that done, we now have a project generated with the right links. You can check the implementation details on the GitHub repository.\nProgramming Game Engine ","date":null,"permalink":"/posts/mage2/","section":"Posts","summary":"Making a game engine - Part 2 - Generating project files and project structure","title":"MAGE - Part 2"},{"content":" A new game engine! Check out Nui Engine on Github Introducing Nui Engine # This game engine project is called Nui Engine and will be built using C++. Unlike most game engines, this will be an editor-less game engine. I want the user to control everything via C++ code. There will be a command console using which the user can communicate with the game engine (such as executing commands like game cheats and getting engine information).\nEngine Architecture # The engine will be split into the following modules:\nNuiCore Built as a static library Contains core engine functionality such as windowing, input and main loop management Also contains the main entry point Links with the NuiGraphics and NuiAudio libraries NuiGraphics Built as a static library Contains the API agnosticc rendering interface NuiAudio Built as a static library Contains all audio related functionality GameCode Built as an executable Contains all user written game code which auto-registers with the engine and is dynamically called Links with NuiCore NuiTest Uses MSTest to test engine functionality (thereforce built as a DLL) Can be extended by the user to test gameplay code Links with all modules ProjectGenerator A collection of templates and python scripts used to generate solution and project files NuiCommandConsole A standalone console application that can communicate with the engine The interprocess communication will be done using pipes See below a diagram of the planned engine architecture.\nNui Engine Architecture With the engine architecture planned, I will next work on generating project files. So that we can then start working on the engine itself.\nThe name \u0026lsquo;Nui\u0026rsquo; was proposed by my univerity lecturer (who I asked for name suggestions) since this engine has no editor (No UI). Thanks Tom!\nProgramming Game Engine ","date":null,"permalink":"/posts/mage1/","section":"Posts","summary":"Making a game engine - Part 1 - Engine architecture","title":"MAGE - Part 1 "},{"content":" Check out Nui Engine on Github Introduction # Heylo and welcome to the start of a new project!\nAs you may have seen from my projects page, I\u0026rsquo;ve been tinkering quite a bit into the world of game development, mostly on the low level side of things. Recently I\u0026rsquo;ve got the itch to make another game engine from scratch and I figured, why not bring you along for the ride?\nSo, here we are! I\u0026rsquo;ve decided to make use of this blog space on my website to document my journey of yet another game engine.\nWhy Document This Journey? # You see, I have a habit of starting projects and abandoning them halfway through. My last documented project was the game engine I made in my final year of university. Since then I\u0026rsquo;ve attempted to make at least 4 other game engines which have never seen the light of day and all are sitting in private repos. They all have an explosive start, but I end up abandoning them a couple months into the project.\nBut not this time! I will use this blog basically as an excuse to hold myself accountable with regular updates and posts, I\u0026rsquo;m gonna stay on track and see this thing through to the end (hopefully 🤞).\nWhat to expect # Well, I\u0026rsquo;ll be sharing everything, from brainstorming sessions, to engine architecture, design decisions and fun C++ tidbits. Some posts might be code-heavy, other might be small bite-sized articles. Let\u0026rsquo;s see how things go :D\nAnd Finally # Hopefully, the future articles are helpful and enjoyable to read. Keeping in mind it\u0026rsquo;s also my first time writing blogs of any kind, so there is definitly some room for improvement.\nI hope you\u0026rsquo;ll stick around for the development of this new project 😄.\nCatch ya around!\nProgramming Game Engine ","date":null,"permalink":"/posts/mage0/","section":"Posts","summary":"Humble beginnings - documenting my journey making a game engine","title":"Making a Game Engine - Part 0"},{"content":" Procrastinating my next project with many unfinished ones in front of me! ","date":null,"permalink":"/posts/","section":"Posts","summary":"Procrastinating my next project with many unfinished ones in front of me!","title":"Posts"},{"content":"Here is a list of all the projects I have worked on over the years. Click on the project to read more about it!\n","date":null,"permalink":"/projects/","section":"Projects","summary":"Here is a list of all the projects I have worked on over the years.","title":"Projects"},{"content":"For my final year project for my university I made a simple 2D game engine. For this project I research what goes into making a game engine and try to implement my learnings. Written in C++ 20, DirectX 11 and HLSL and based on and ECS and event-driven architecture. The editor is also written in C++ using ImGui. It also supports entity scripting using Lua.\nCheck out the project repository on Github. Watch the demo video here\nArchitecture # The project consists of two sub projects - The Engine and the The Editor. The engine compiles to a static library (.lib) and the editor compiles to an executable (.exe)\nProximity Engine Architecture Proximity\u0026rsquo;s architecture is inspired from Hazel and the initialization chain is inspired from Unreal Engine.\nProximity Engine Initialization Chain Engine Features # Watch the demo video Here are the key features of the engine, some of which are explained in detail after:\nWindow and Input Handling Audio Engine using XAudio2 Custom math library Event driven architecture using Actions Graphics engine and rendering using DirectX 11 Filesystem and directory management Engine logging system Engine utilities Asset libraries (Audio, Shaders, Material, Textures, Scripts) Memory managers (Stack and Pool Allocators) Detailed HLSL shader reflection Scripting using Lua Physics using Box2D Game/Project Serialization using Yaml-Cpp Multiple scenes and project management Entity Component System using ENTT Proximity Editor HLSL Shader Reflection # One of the most impressive features of the game engine is the shader reflection system. The user can write any HLSL code (vertex or pixel shader). The shader is then compiled and reflected within in the engine. The user can then create a Material which is a pair of vertex and pixel shaders. This material is then reflected in the editor; constant buffers and input resource slots can be manually edited from within the editor\nShader reflection system Actions # I recreated the System.Action\u0026lt;\u0026gt; class from C# in C++ 20. And this is what drives the communicatation between the engine and the editor and between the different editor panels.\nThe user can create custom action events (which may or may not take arguments) and bind their own functions/lamdas to these actions. Whenever an action is called, all the bound functions to this action are also called.\nLua Scripting # The engine supports entity scripting using Lua and the Sol2 library. The engine creates a custom runtime environment for each script in the game. The user can call functions to and from C++ and Lua and all of this is made easy using the Sol2 library. The scripts are written in the built in script editor which also has support for syntax hightlighting for engine specific functions.\nConclusion # During this project, I learnt so many new things about C++, HLSL, DirectX 11 as a whole. I believe I have built this project to be the showcase of my skills a C++ and engine programmer and is definitely will be the highlight project of my portfolio along with being the most complex project I\u0026rsquo;ve worked on till date. With some changes to the project and scope, I will definitely make Proximity 2.0, which will be faster with even more supported features.\nI did not talk about the intricate details about all the features of this project or this would turn into a 30 minute long article. But you can always check out the project repository on github or contact me :)\nC++ DirectX 11 HLSL Lua ImGui Programming Game Engine Backend Development ","date":null,"permalink":"/projects/proximityengine/","section":"Projects","summary":"2D C++ and DirectX 11 game engine I made for my final year project","title":"Proximity Game Engine"},{"content":"I have always wanted to try making a complex Ai system before (better than a FSM). And in that list, there were two main ones. GOAP and Neural Networks, specifically NEAT and Genetic Algorithms. Although my original plan for this module was to make a platformer (similar) to Super Mario Bros. and train a NEAT algorithm on it. Due to the scope and time constraints, I decide to drop that idea and move on to make GOAP in a survival game.\nUnderstanding GOAP # GOAP stands for Goal Oriented Action Planning.\nThe way GOAP works is takes in a starting world state and a goal (target world state). These two, along with a list of all possible actions are sent into the planner. The planner generates a list of actions to take by performing A* search in the actions list based on the preconditions and effect of the provided actions.\nHow I Deal With GOAP # In my implementation of GOAP in Unity. I do not have any classes that define a goal. Everything is defined as a world state.\nC# files for implementing GOAP in Unity Which means the planner takes in the current world state and the target world state (and the actions list).\nThe actions are built by setting preconditions and effects on the world state and by providing a delegate that is executed when an action is executed.\nHere is a snippet of code from my implementation\n// Create a new action called move to drinking point and give it an execution cost GOAP.Action moveToDrinkingPoint = new(\u0026#34;Move to drinking point\u0026#34;, MOVEMENT_COST); // Precondition world state for this action to be executed is that \u0026#39;Player Is Thristy = true\u0026#39; moveToDrinkingPoint.SetPrecondition((int)WorldKey.PlayerIsThristy, true); // The effect of the action on the world state on execution is \u0026#39;Play Is Going To Drink = true\u0026#39; moveToDrinkingPoint.SetEffect((int)WorldKey.PlayerIsGoingToDrink, true); // Set up the function that is called when the action is executed and the function that checks if this action can execute on the current world state (runtime check) moveToDrinkingPoint.SetupExecution( () =\u0026gt; // Execution { m_player.MoveAStar(m_drinkingPoint.transform.position); }, () =\u0026gt; // Checker { // Returns true id the player has reached the drinking point return m_player.HasReachedDestination; }) Like that multiple actions can be set up. The planner then chains them up based on matching preconditions and effects (using A*).\nAction/Goal Chart # Here is a chart showing all the actions and their desired preconditions and effects\nAction/Goal relationship chart Along with GOAP, this project has a comprehensive 2D tilemap terrain analysis system (visualization shown in the cover image)\nCheck out the demo and walkthrough on YouTube Check out the project repository on Github C# Ai Unity Game Development ","date":null,"permalink":"/projects/goapai/","section":"Projects","summary":"GOAP in Unity","title":"Goal Oriented Action Planning in Unity"},{"content":"Incognito is a rogue-lite procedural stealth game made in Unreal Engine 5 using C++ and Blueprints. The player playes through a series of rooms (level). After finishing a level, they are brought back to the hub where they can choose weapon and stealth upgrades for their next run. Due to procedural level generation, each level/run is different.\nGame Trailer My Role # This game was made during a university studio simulation module where second and third year students from various fields in game development (design, art, sound, programming) get together to make a game in 6 weeks. The seniors act like deparment leads and the juniors work along with and learn under their guidance.\nThe goal of this module was to make a game in 6 weeks. This game did not have be a complete game, but a vertical slice of a possible game with as many features added that time would allow.\nI was the tech lead and project manager for a team of 22 students. I made the core gameplay systems and the procedural algorithm that generates the map/levels of the game.\nIncogniito Promotional Art My Work # As the Project Manager # As the project manager, my role was to make sure all the other seniors (deparment leads) were on track and make sure the juniors were completing the tasks assigned to them. This was done using Jira to make sure all work was done in time. I also was heavily invovled in deciding the scope of the project.\nAs the Tech Lead # As the tech lead, my role was to design and implement the core gameplay systems and also build a framework easy enough so that the jkuniors can take over along with being designer friendly. Along with feature implementation, I also had to perform version control on the project and handle various department branches and merge conflicts. Most of the version control management was done using command line Git (since handling merge conflicts for UE5 blueprints is a pain).\nManaging the project via Git Procedural Level Generation # Incognito is a stealth game where the levels the user plays (internally referred to as rooms) are generated based on a stripped down version of the Wave Function Collapse (WFC) Algorithm. All the code for the generation was written in C++ and was highly optimized (100 rooms generated in about 2 seconds).\nGenerating 100 rooms using WFC (for fun) The code was written in such a way that no designer ever had to touch any C++. All required functionality was exposed to the Unreal Editor.\nI provided the designers with a list of templates for each type of room they had to make. All these rooms were then input into a custom data table (written in C++).\nRoom layout template provided to designers The rooms were divided into three types based on the number of openings they had:\nC-Type Rooms: Rooms with 1 opening L-Type Rooms: Rooms with 2 openings adjacent to each other I-Type Rooms: Rooms with 2 openings opposite to each other Each type of room had 4 variants (for every type of rotation). All that was needed to be done was to fill in th neighbor and connections info in the data table. Provide the data table to the generator and generate the level when needed.\nDesigner friendly room layout infographic Additional Work # Enemy Ai # I also worked on other features such as developing the core (3 layer) communication system for all the Ai that was spawned in each room:\nAi-Ai communication: One Ai enemy communicating with other nearby Ai enemies Ai-Room communication: Ai enemies communicating with the room to ambush the player in lockdown mode Room-Level communication: Each room communicated with a game manager gathering telemetry data such as number of enemies killed and how stealthily the player completed a room. This was also used to check if a certain level was finished I also worked on building a base for all Ai enemies, which was later extended by other senior programmers.\nLockdown Mode # One of the most fun features of this game is the Lockdown Mode I helped build with the other senior programmer on the team. It was like a panic mode in the game. If during a player\u0026rsquo;s \u0026rsquo;escape\u0026rsquo; from a room was caught by the Ai. All the enemies in the room would be made aware of the players location and they would collectively attack the player. During this phase, the player no longer has to complete the level stealthily. They have to kill as many enemies, find the key to the exit and leave the room. This intermediate game mode totally changed the way the game is played.\nIf the player managed to find the key and exit the room without killing all the enemies in the room. The next entered room would begin on lockdown mode (keeping in mind player has limited ammo and health)\nDynamic Enemy Wander # One of features I worked on a dynamic enemy wander system. Since all the rooms were pre-built by designers and the generator only placed the room in the game world. If the enemy roaming spots were already pre-defined, the player could simply remember them and easily defeat a room.\nTo counter this, I made use of th Unreal\u0026rsquo;s Environmnet Query System (EQS) to get a random list of wander points based on multiple criterias. These wander points would be randomized and shuffled for each enemy in each room.\nCheck out the project repository on Github Game Unreal Engine C++ Ai Blueprints Team Work Programming Management Design Game Dev ","date":null,"permalink":"/projects/incognito/","section":"Projects","summary":"Procedural rogue-lite game made in UE5","title":"Incognito"},{"content":"This project demonstrates my skills in advanced rendering techniques. Written using C++ and DirectX 11 using a custom framework.\nHere are the features of the project\nOBJ Mesh Loading User input (mouse and keyboard) Forward Rendering Deferred Rendering Point Light Support Normal Mapping Parallax Mapping with Self Shadowing using Ray Tracing (forward rendering only) Render to Texture Render to Full Screen Quad Screen Space Effects (vignette, grayscale, etc.) G-Buffer Visualization Check out the project repository on Github Tech Demo C++ DirectX 11 HLSL Graphics Rendering Engine Programming Backend Development ","date":null,"permalink":"/projects/advancedgraphics/","section":"Projects","summary":"Project demonstrating advanced graphics techniques in DirectX 11","title":"Advanced Graphics"},{"content":"A bare bones attempt at a 2D/3D game engine. Used this project to prepare for making Proximity 2D in an attempt to find my ideal engine architecture. Written in C++ using the DirectX 11. Inspired from the Hazel Game Engine from The Cherno.\nCheck out the project repository on Github C++ DirectX 11 HLSL Programming Game Engine Backend Development ","date":null,"permalink":"/projects/primeengine/","section":"Projects","summary":"Prototype game engine made as practice","title":"Prime Engine"},{"content":"A short top down shooter game made in the Unity Game Engine.\nThe player has to clear a procedurally generated dungeon where the current gun weilded by the user is randomly changed.\nThe game\u0026rsquo;s difficult increases the longer the player is alive with various enemy types and the number of enemies.\nCheck out the project repository on Github Game C# Unity Programming ","date":null,"permalink":"/projects/topdownshooter/","section":"Projects","summary":"Top down shooter game made in Unity","title":"Unity Top Down Shooter"},{"content":"Made for my second university year, this project was my first introduction to the DirectX 11 API, making it my first ever rendering engine.\nFeatures:\nLighting Directional Lights Point Lights Mesh Loading Vector3 Class GameObject Class Texture2D Class Camera Static Camera Orbit Camera First Person Camera Sky sphere Terrain Rendering Editable terrain colors using ImGui and shaders Circular Wave Generator Using Vertex Shaders Editable using ImGui Check out the project repository on Github C++ DirectX 11 HLSL Programming Rendering Engine Backend Development ","date":null,"permalink":"/projects/renderingengine/","section":"Projects","summary":"Simple rendering engine (C++ and DX11)","title":"DX11 Rendering Framework"},{"content":"This was my first project where I made a game without using an engine in C++ using SDL2\nThis platformer framework has the following features:\nSprite loading / texture class Import collision map from CSV file Simple 2D physics engine Text class Audio manager Page scrolling system Multi scene support UI buttons 2 different Ai enemies Collectible coins 2 player control support Player health/damage system Player attack bullets Project menu screen Check out the project repository on Github C++ SDL 2 Programming Game Engine Game Development ","date":null,"permalink":"/projects/sdlplatformer/","section":"Projects","summary":"Mario remake using SDL","title":"SDL 2 Mario Remake"},{"content":"Dimension Drift is a short puzzle game made for the GMTK Game Jam 2021 in 48 hours.\nThe theme of the game jam was Joined Together. In this game you solve puzzles while switching between dimensions each having its own restrictions in movement. You can move forward and backward in 2D, but change your depth position in 3D.\nPLAY THE GAME! Images # Here are some screenshots from the game\nDimension Drift Gameplay Image 1 Dimension Drift Gameplay Image 2 Dimension Drift Gameplay Image 3 Project Tags # Game Jam Unity C# Programming Game Dev GMTK Game Jam 2021 ","date":null,"permalink":"/projects/dimensiondrift/","section":"Projects","summary":"Puzzle game made for GMTK Game Jam 2021","title":"Dimension Drift [GMTK Game Jam 2021]"},{"content":"This game was made for the Ai and Games Jame 2021. The main goal of the project was to improve my AI development and design skills.\nThe theme of this game jam was Breaking The Rules. So in this game the robots broke the Three Laws of Robotics made by Issac Assimov (hence the name).\nIn this game you play as a robot, where you break Asimov\u0026rsquo;s 3 rules/laws of robotics by fighting against intelligent AI.\nHow the AI Works # This was the first time I made my own Finite State Machine (FSM) framework in Unity.\nBy default the enemy robots will wander around If the player comes in the field of vision, they will switch to chase state and follow the player Once close enough the enemy will start shooting the player If the enemy itself takes enough damage, it will try to take cover by finding the nearest safe cover spot If it stays safe for some time without the player noticing, backup will be called (3 enemies are spawned) The main goal of the player should be to prevent the enemy robot from going to safety and calling for backup whilst trying to complete the game in the quickest time possible Images # Here are some screenshots from the game:\nAgainst Asimov Gameplay Image 1 Against Asimov Gameplay Image 2 Against Asimov Gameplay Image 3 Download and play the game on Itch.io C# Ai Unity Game Jam AI and Games Jam 2021 Game Development ","date":null,"permalink":"/projects/asimov/","section":"Projects","summary":"Submission for AI and Games Jam 2021","title":"Against Asimov [Ai and Games Jam 2021]"},{"content":"Maze Meltdown is a horror game I made when I took part (solo) in the Global Game Jam held in my university.\nHaving never worked with audio in Unity before. I used this game jam as an oppurtunity to learn about audio programming in Unity,\nSee playthrough video on YouTube Play the game on Itch.io Check out the project repository on Github Game C# Unity Programming Global Game Jam 2021 ","date":null,"permalink":"/projects/mazemeltdown/","section":"Projects","summary":"Horror game made for Global Game Jam 2021","title":"Maze Meltdown [Global Game Jam 2021]"},{"content":"This game was made for the Discord Jam #5. The theme for this game jam was Mutation.\nIn this game, the ball is an experiment which has different DNA structures which give it different powers (which are both positive and negative in effect), only for a set amount of time.\nThese changes in powers is denoted by the change in color of the ball.\nImages # Here are some screenshots from the game:\nMutant Mashup Gameplay Image 1 Mutant Mashup Gameplay Image 2 Download and play the game on Itch.io C# Unity Game Jam Discord Jam #5 Game Development ","date":null,"permalink":"/projects/mutant/","section":"Projects","summary":"Submission for Discord Jam #5","title":"Mutant Mashup [Discord Jam #5]"},{"content":"A short puzzle platformer made for the Brackeys Game Jam 2020.2\nYou play as a bot, whose goal is to put all the energy cubes into their energy bars, so as to progress to the next level. But here\u0026rsquo;s the catch, you cannot reach some parts of the level. For those areas you have to reverse the time for specific objects, to make them work like moving platforms.\nPlay online on Itch.io C# Unity Game Jam Brackeys Game Jam 2020.2 Game Development ","date":null,"permalink":"/projects/timetraversal/","section":"Projects","summary":"Submission for Brackeys Game Jam 2020.2","title":"Time Traversal [Brackeys Game Jam 2020.2]"},{"content":"This game was made for the GMTK Game Jam 2020, where the theme was Out of Control. This was my first ever 3D game made in Unity.\nIn this game, time is out of control. The game speeds up and slows down as per the supposed AI\u0026rsquo;s wish.\nImages # Here are some screenshots from the game:\nTurbulent Time Gameplay Image 1 Turbulent Time Gameplay Image 2 Download the game on Itch.io C# Unity Game Jam Discord Jam #5 Game Development ","date":null,"permalink":"/projects/turbulenttime/","section":"Projects","summary":"Submission for GMTK Game Jam 2020","title":"Turbulent Time [GMTK Game Jam 2020]"},{"content":"This game was made the for the United Game Jam 2020, who\u0026rsquo;s theme was Two. This was my second ever game made in Unity.\nIn this game, the player controls two characters in different dimensions. The goal of the game is make the two characters reach the end of the level before the red barrier kills them.\nIn this project I focused on making smooth camera that tracks and encompasses both the players.\nImages # Here is a screenshot from the game:\nTurbulent Time Gameplay Image 2 Download the game on Itch.io C# Unity Game Jam United Game Jam 2020 Game Development ","date":null,"permalink":"/projects/binaryrift/","section":"Projects","summary":"Submission for the United Game Jam 2020","title":"Binary Rift [United Game Jam 2020]"},{"content":"Introduction # Hey there! I am Arnav, and you are currently having a one-sided-textual-probably-monotonous-talk with me through this page :)\nA picture of me touching grass XD Game Development and Backend Focus # I recently completed my BSc (Hons) Computer Games Design and Programming degree from Staffordshire University (2020-2023). Game development has always been my jam, and I\u0026rsquo;ve had a blast working with Unity and Unreal game engines.\nWhile game development is my passion, I\u0026rsquo;ve discovered a special love for backend development. I\u0026rsquo;m fascinated by the inner workings of game engines, rendering engines, and the tools that power the magic. As part of my final year project, I even built a game engine from scratch, which you can explore in my portfolio.\nI\u0026rsquo;m well-versed in the art of coding and consider C++ and C# to be my trusty sidekicks. Additionally, I\u0026rsquo;ve dabbled in DirectX 11 and HLSL, which have allowed me to create some complex projects over the years. Along with being well versed in version control tools like Git/Github and project management tools like Jira.\nI thrive on analytical and logical thinking, transforming problem-solving into an exhilarating adventure. With a solid foundation in mathematics, including vector math and the mathematical principles behind graphics programming, I bring a unique perspective to crafting immersive and engaging games that prioritize functionality over aesthetics.\nPassion for Game Jams # In addition to my passion for game development, I absolutely love taking part in game jams. Although I am not much of a gamer myself.\nThese intense and creative events allow me to challenge myself and explore new ideas within tight deadlines. For every game jam that I take part in, I try to learn something new. All my game jam games, although not very fun to play showcase me learning a new feature and trying it out for the first time. I\u0026rsquo;ve had the opportunity to participate in several exciting game jams, including:\n🎮 101 Hours Jam #2 🎮 United Game Jam 2020 🎮 GMTK Game Jam 2020 🎮 Brackeys Game Jam 2020.2 🎮 Discord Game Jam #5 🎮 Ai and Games Jam 2021 🎮 GMTK Game Jam 2021 🎮 Global Game Jam 2021 🎮 Ukie Game Jam 2021 🎮 Global Game Jam 2022\n101 Hours Jam was my first ever game jam. This is also the game jam where I opened Unity for the first time. I ended up learning Unity and making a game in it within the 101 hours Ai and Games Jam was the first game jam where I learn to work with and design complex Ai behaviours (in Unity) using a custom Finite State Machine framework During Global Game Jam 2021 I decided to make a horror game so I could learn advanced sound design in Unity These experiences have been invaluable in sharpening my problem-solving skills, fostering creativity, and collaborating with like-minded individuals. Game jams have pushed me to think on my feet, iterate rapidly, and create unique and memorable game experiences within a limited timeframe.\nI always look forward to the thrill and excitement of game jams, and I\u0026rsquo;m excited to continue participating in these events to further expand my skills and explore the vast possibilities of game development. It also builds my teamworking skills and understanding the different roles in game development.\nLike all programmers I love spending 10 hours automating something I could have manually done in 10 mintues Connect with me on Linkedin ","date":null,"permalink":"/aboutme/","section":"Home","summary":"Introduction # Hey there!","title":"About Me"},{"content":"","date":null,"permalink":"/categories/","section":"Categories","summary":"","title":"Categories"},{"content":"","date":null,"permalink":"/tags/","section":"Tags","summary":"","title":"Tags"}]