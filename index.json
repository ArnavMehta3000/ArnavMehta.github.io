[{"content":"","date":null,"permalink":"/","section":"Home","summary":"","title":"Home"},{"content":" From Premake to Xmake! Check out Nui Engine on Github In Part 2, I decided to make use of Premake5 to generate my visual studio solution files. Premake not not a complete build system (like CMake), instead it is only useful to generate IDE solution/project files. Now that Nui Engine has grown quite a bit, I have decided to migrate to a new build system called Xmake.\nWhat is Xmake? # From Xmake\u0026rsquo;s website:\nXMake is a cross platform and lightweight Lua based build utility. Xmake can be used to directly build source code (like Make or Ninja), or it can also be used to project generate source files like XMake or Meeson. Xmake comes with its own package manager called XRepo, but also supports compiling external CMake based projects. Xmake = Build backend + Project Generator + Package Manager + [Remote|Distributed] Build + Cache\nIn other words:\nXmake ‚âà Make/Ninja + CMake/Meson + Vcpkg/Conan + distcc + ccache/sccache\nMigrating From Premake to Xmake # Removing Premake Files # First step in migrating from Premake to Xmake, involves deleting all Premake Lua build scripts and the Premake5 binary.\nRemove:\nBuildCore.lua BuildGraphics.lua BuildTestbench.lua Template script files CreateProject.py (Python script that created the empty project for us) Premake5.exe Understanding Xmake # After we have removed Premake file, we have to create the xmake.lua file in the project root. But before we can do that we need to understand how xmake handles solutions/projects.\nIn Xmake you create a new project, this is equivalent to your solution. Premake\u0026rsquo;s equivalent to solution projects in Xmake is referred to as a target A single project can have multiple targets (similar to how a visual studio solution can have multiple projects) Targets and projects have rules applied to them. These can be custom rules or in-built. Creating Root xmake.lua # We will start by creating a new file in the project root called xmake.lua, this file will handle including all of our other projects and actions (explained later).\nlocal solution_name = \u0026#34;Nui\u0026#34; -- XMake version set_xmakever(\u0026#34;2.9.2\u0026#34;) -- Build configs add_rules(\u0026#34;mode.debug\u0026#34;, \u0026#34;mode.release\u0026#34;, \u0026#34;mode.releasedbg\u0026#34;) set_allowedmodes(\u0026#34;debug\u0026#34;, \u0026#34;release\u0026#34;, \u0026#34;releasedbg\u0026#34;) -- Platform and architecture - only support x64 Windows set_allowedplats(\u0026#34;windows\u0026#34;) set_allowedarchs(\u0026#34;windows|x64\u0026#34;) -- Set C/C++ language version set_languages(\u0026#34;c17\u0026#34;, \u0026#34;cxx23\u0026#34;) -- Project name and version set_project(solution_name) set_version(\u0026#34;0.0.1\u0026#34;) -- Set default build mode set_defaultmode(\u0026#34;debug\u0026#34;) -- Generate clang compile commands on build -- add_rules(\u0026#34;plugin.compile_commands.autoupdate\u0026#34;) -- Update generated visual studio project files on build -- add_rules(\u0026#34;plugin.vsxmake.autoupdate\u0026#34;) -- Add defines add_defines(\u0026#34;UNICODE\u0026#34;) if is_mode(\u0026#34;debug\u0026#34;, \u0026#34;releasedbg\u0026#34;) then add_defines(\u0026#34;NUI_DEBUG\u0026#34;) end if is_mode(\u0026#34;release\u0026#34;) then add_defines(\u0026#34;NUI_RELEASE\u0026#34;) end -- Include all xmake projects includes(\u0026#34;**/xmake.lua\u0026#34;) A big chunk of this file is self explanatory, but here is a detailed explanation of what is happening in this file.\nSince it is a Lua script, I have a local variable at the start that will allow the end user to choose a solution name (only important if generating IDE files) Next I set the minimum Xmake version, which is the latest at the time of writing I then add rules and build configurations for all projects. I want to support Debug, ReleaseDbg and Release which is similar to my Premake configuration of Debug, Release and Shipping. These modes are built into Xmake so that means that I do not have to spend a lot of time configuring each compiler setting Next I set the project name and version After that, based on the build configuration/mode, I set the Nui macro defines Creating Engine xmake.lua # The engine build files in this case are the xmake.lua scripts for the Engine and Graphics projects. They both are very similar:\nFor Nui Graphics project:\ntarget(\u0026#34;NuiGraphics\u0026#34;) set_default(false) set_kind(\u0026#34;static\u0026#34;) add_files(\u0026#34;**.cpp\u0026#34;) add_headerfiles(\u0026#34;**.h\u0026#34;) add_includedirs(\u0026#34;$(scriptdir)/Engine/\u0026#34;) add_links(\u0026#34;User32.lib\u0026#34;) set_group(\u0026#34;Nui\u0026#34;) target_end() For Nui Core project:\ntarget(\u0026#34;NuiCore\u0026#34;) set_default(false) set_kind(\u0026#34;static\u0026#34;) add_files(\u0026#34;**.cpp\u0026#34;) add_headerfiles(\u0026#34;**.h\u0026#34;) add_extrafiles(\u0026#34;$(projectdir)/Engine/External/DirectXTK.inl\u0026#34;) add_includedirs(\u0026#34;$(scriptdir)/Engine/\u0026#34;) add_links(\u0026#34;NuiGraphics\u0026#34;, \u0026#34;User32.lib\u0026#34;) add_deps(\u0026#34;NuiGraphics\u0026#34;) set_group(\u0026#34;Nui\u0026#34;) target_end() These script files are quite straight forward\nHere I am creating two targets called NuiCore and NuiGraphics Both have set_default to false, since we do not want to run them on startup Both are static libraries Both have thier include paths, external files and library links and dependencies set up They both are part of the Nui group Generating User Project Files # When using premake, I had a Python script that generated the premake lua script and set up the directories. When using xmake, I do have have to make use of that. Xmake allows running of custom lua script and also supports custom commands. So that is what we will use.\nNui Create Action # Xmake allows creation of actions and plugins which are basically custom commands. I want to create a command called nui-create which would create a new game project. So it would look something like this.\nxmake nui-create -p Testbench In the Scripts folder, let\u0026rsquo;s create a new xmake.lua file. This file will contain all the custom commands that we will use. Starting with create a new project\n-- Task to create a new Nui game project task(\u0026#34;nui-create\u0026#34;) set_category(\u0026#34;action\u0026#34;) on_run(\u0026#34;CreateProject\u0026#34;) -- Set the command line options for the plugin. There are no parameter options here, just the plugin description. set_menu { -- Settings menu usage usage = \u0026#34;xmake nui-project [project-name]\u0026#34;, -- Setup menu description description = \u0026#34;Create a new Nui project\u0026#34;, -- Set menu options, if there are no options, you can set it to {} options = { -- Set kv as the key-value parameter and set the default value: black {\u0026#39;p\u0026#39;, \u0026#34;project\u0026#34;, \u0026#34;kv\u0026#34;, \u0026#34;NuiGame\u0026#34;, \u0026#34;Set the project name.\u0026#34; } } } task_end() Since the file is also called xmake.lua, it is automatically picked by our root xmake.lua file. Thanks to pattern matching!\nIn this script\nWe create a new action (category) called nui-create Whenever this action is triggered (on_run), we will run another Lua file called CreateProject.lua We can set the menu setting as well, which will be displayed when we add the -h or --help flag Now if we run the command: xmake -h, you will see the nui-create action\nIf you run the following command:\nxmake nui-create -h We get the following output:\nPS E:\\Dev\\NuiEngine\u0026gt; xmake nui-create -h xmake v2.9.2+master.33f3078f4, A cross-platform build utility based on Lua Copyright (C) 2015-present Ruki Wang, tboox.org, xmake.io _ __ ___ __ __ __ _| | ______ \\ \\/ / | \\/ |/ _ | |/ / __ \\ \u0026gt; \u0026lt; | \\__/ | /_| | \u0026lt; ___/ /_/\\_\\_|_| |_|\\__ \\|_|\\_\\____| by ruki, xmake.io üëâ Manual: https://xmake.io/#/getting_started üôè Donate: https://xmake.io/#/sponsor Usage: $xmake nui-project [project-name] Create a new Nui project Common options: -q, --quiet Quiet operation. -y, --yes Input yes by default if need user confirm. --confirm=CONFIRM Input the given result if need user confirm. - yes - no - def -v, --verbose Print lots of verbose information for users. --root Allow to run xmake as root. -D, --diagnosis Print lots of diagnosis information (backtrace, check info ..) only for developers. And we can append -v to get more whole information. e.g. $ xmake -vD -h, --help Print this help message and exit. -F FILE, --file=FILE Read a given xmake.lua file. -P PROJECT, --project=PROJECT Change to the given project directory. Search priority: 1. The Given Command Argument 2. The Envirnoment Variable: XMAKE_PROJECT_DIR 3. The Current Directory Command options (nui-create): -p PROJECT, --project=PROJECT Set the project name. (default: NuiGame) At the bottom of this output, you can see the usage help message we defined in set_menu.\nCreate Project Lua Script # Now if we create a new Lua script called CreateProject.lua in the same directory as the above xmake.lua script - ./Scripts/CreateProject.lua, when we run this action with a project name, it will run this Lua file.\nimport(\u0026#34;core.base.option\u0026#34;) projectName = nil templatesPath = nil scriptDir = nil rootDir = nil projectDir = nil function CreateXmakeFile() -- Get file paths local templateFilePath = path.join(templatesPath, \u0026#34;XmakeProjectTemplate\u0026#34;) local outputFilePath = path.join(projectDir, \u0026#34;xmake.lua\u0026#34;) -- Get template file contents local templateFile = io.open(templateFilePath, \u0026#34;r\u0026#34;) if not templateFile then raise(\u0026#34;Failed to open xmake template file. Expected path: \u0026#34; .. templateFilePath) end local templateContent = templateFile:read(\u0026#34;*all\u0026#34;) templateFile:close() -- Replace \u0026#39;%PROJECT_NAME%\u0026#39; with the actual project name local modifiedContent = templateContent:gsub(\u0026#34;%%PROJECT_NAME%%\u0026#34;, projectName) -- Create and write to the output file local outputFile = io.open(outputFilePath, \u0026#34;w\u0026#34;) if not outputFile then error(\u0026#34;Failed to write xmake project file. Expected path: \u0026#34; .. outputFilePath) end outputFile:write(modifiedContent) outputFile:close() cprint(\u0026#34;Created project file: ${underline}%s\u0026#34;, outputFilePath) end function CreateMainCppFile() -- Get file paths local templateFilePath = path.join(templatesPath, \u0026#34;MainCppProjectTemplate\u0026#34;) local outputFilePath = path.join(projectDir, \u0026#34;Main.cpp\u0026#34;) -- Get template file contents local templateFile = io.open(templateFilePath, \u0026#34;r\u0026#34;) if not templateFile then raise(\u0026#34;Failed to open xmake template file. Expected path: \u0026#34; .. templateFilePath) end local templateContent = templateFile:read(\u0026#34;*all\u0026#34;) templateFile:close() -- Replace \u0026#39;%PROJECT_NAME%\u0026#39; with the actual project name local modifiedContent = templateContent:gsub(\u0026#34;%%PROJECT_NAME%%\u0026#34;, projectName) -- Create and write to the output file local outputFile = io.open(outputFilePath, \u0026#34;w\u0026#34;) if not outputFile then error(\u0026#34;Failed to write xmake project file. Expected path: \u0026#34; .. outputFilePath) end outputFile:write(modifiedContent) outputFile:close() cprint(\u0026#34;Created main file: ${underline}%s\u0026#34;, outputFilePath) end function CreateApplicationHeaderFile() -- Get file paths local templateFilePath = path.join(templatesPath, \u0026#34;ApplicationHeaderProjectTemplate\u0026#34;) local outputFilePath = path.join(projectDir, path.join(projectName, projectName .. \u0026#34;App.h\u0026#34;)) -- Get template file contents local templateFile = io.open(templateFilePath, \u0026#34;r\u0026#34;) if not templateFile then raise(\u0026#34;Failed to open xmake template file. Expected path: \u0026#34; .. templateFilePath) end local templateContent = templateFile:read(\u0026#34;*all\u0026#34;) templateFile:close() -- Replace \u0026#39;%PROJECT_NAME%\u0026#39; with the actual project name local modifiedContent = templateContent:gsub(\u0026#34;%%PROJECT_NAME%%\u0026#34;, projectName) -- Create and write to the output file local outputFile = io.open(outputFilePath, \u0026#34;w\u0026#34;) if not outputFile then error(\u0026#34;Failed to write xmake project file. Expected path: \u0026#34; .. outputFilePath) end outputFile:write(modifiedContent) outputFile:close() cprint(\u0026#34;Created application header file: ${underline}%s\u0026#34;, outputFilePath) end function CreateApplicationCppFile() -- Get file paths local templateFilePath = path.join(templatesPath, \u0026#34;ApplicationCppProjectTemplate\u0026#34;) local outputFilePath = path.join(projectDir, path.join(projectName, projectName .. \u0026#34;App.cpp\u0026#34;)) -- Get template file contents local templateFile = io.open(templateFilePath, \u0026#34;r\u0026#34;) if not templateFile then raise(\u0026#34;Failed to open xmake template file. Expected path: \u0026#34; .. templateFilePath) end local templateContent = templateFile:read(\u0026#34;*all\u0026#34;) templateFile:close() -- Replace \u0026#39;%PROJECT_NAME%\u0026#39; with the actual project name local modifiedContent = templateContent:gsub(\u0026#34;%%PROJECT_NAME%%\u0026#34;, projectName) -- Create and write to the output file local outputFile = io.open(outputFilePath, \u0026#34;w\u0026#34;) if not outputFile then error(\u0026#34;Failed to write xmake project file. Expected path: \u0026#34; .. outputFilePath) end outputFile:write(modifiedContent) outputFile:close() cprint(\u0026#34;Created application cpp file: ${underline}%s\u0026#34;, outputFilePath) end function CreateAssetsFolder() -- Get asset directory local assetDir = path.join(projectDir, \u0026#34;Assets\u0026#34;) -- Create assets folder os.mkdir(assetDir) cprint(\u0026#34;Created assets directory: ${underline}%s\u0026#34;, assetDir) end function main() -- Get parameter content and display information projectName = option.get(\u0026#34;project\u0026#34;) -- Scripts directory scriptDir = os.scriptdir() -- Root Nui directory rootDir = os.projectdir() -- User project directory projectDir = path.join(rootDir, projectName) -- Template files directory templatesPath = path.join(scriptDir, \u0026#34;Templates\u0026#34;) -- Create project xmake file CreateXmakeFile() -- Create Main.cpp file CreateMainCppFile() -- Create \u0026lt;Project\u0026gt;App.cpp file CreateApplicationCppFile() -- Create \u0026lt;Project\u0026gt;App.h file CreateApplicationHeaderFile() -- Create assets folder CreateAssetsFolder() cprint(\u0026#34;${green}Done\u0026#34;) end Here in this file, I have a bunch of template files, which have %PROJECT_NAME% in them. This script takes those templates, replaces that string with the passed in project name and creates new project files in the directories in the root directory.\nHere I do not discuss the contents of the template files, since the the contents are similar to what we have discussed in the past. If you want to take a look at the contents of the template files then you can check them out on the repository.\nConclusion # I know this article was meant to expand on the previous ECS framework that we built. But I ended up changing the build system and decided to talk about this first. In the next one I will go back to the ECS framework and continue building the engine.\nProgramming Game Engine C++ Build Systems ","date":null,"permalink":"/posts/mage8/","section":"Posts","summary":"Making a Game Engine - Part 8 - New Build System","title":"MAGE - Part 8"},{"content":" Entities, Components and Systems! Check out Nui Engine on Github Finally we are at a point where we can run the application, see the initialization, update and shutdown sequence, along with frame timing. The next thing we will be working on is the Entity Component System, or ECS for short.\nECS Architecture # Since I am writing a custom ECS framework, I wanted to design it with Systems being the main focus. I will say now that this is by no means the best ECS implementation or the fastest. I\u0026rsquo;ve always wanted to learn and figure out how to write my own ECS framework.\nIn the repository take a look at the Docs/Resources.txt file for the resources I used when making this ECS framework\nHere is the planned file structure\nNuiEngine/ ‚îî‚îÄ‚îÄ Engine/ ‚îî‚îÄ‚îÄ Core/ ‚îî‚îÄ‚îÄ Engine/ ‚îî‚îÄ‚îÄ ECS/ ‚îú‚îÄ‚îÄ Common.h ‚îú‚îÄ‚îÄ Component.h ‚îú‚îÄ‚îÄ Context.h ‚îú‚îÄ‚îÄ ECS.h ‚îú‚îÄ‚îÄ Entity.cpp ‚îú‚îÄ‚îÄ Entity.h ‚îú‚îÄ‚îÄ Event.h ‚îî‚îÄ‚îÄ System.h Since ECS (in C++) are usually heavily templated systems, we are going to define most of the functions in the headers files and create almost all implementations in the ECS.h header file.\nNOTE! This article doesn\u0026rsquo;t go into full ECS implementation detail and just covers the ECS classes outline. To see the implementation details, check out ECS.h or the ECS folder (mentioned above) in the repository The Common ECS File # All ECS headers will include the ECS/Common.h header file. This file will include the Engine common header along with a couple forward declarations and a helper function.\n#pragma once #include \u0026#34;Core/Common/CommonHeaders.h\u0026#34; #include \u0026lt;type_traits\u0026gt; #include \u0026lt;typeinfo\u0026gt; #include \u0026lt;typeindex\u0026gt; // Contains ECS forward declarations namespace Nui::ECS { using TypeIndex = std::type_index; class Context; class Entity; class SystemBase; namespace Internal { class EntityView; class EventSubscriberBase; template\u0026lt;typename... Types\u0026gt; class EntityComponentView; } template \u0026lt;typename T\u0026gt; class ComponentHandle; template \u0026lt;typename T\u0026gt; class EventSubscriber; template \u0026lt;typename T\u0026gt; constexpr TypeIndex GetTypeIndex() { return TypeIndex(typeid(T)); } } Take notice of the Nui::ECS::Internal namespace, we will be using that quite a bit to hide implementation details of certain classes\nIn this file:\nWe make an alias for std::type_index called Nui::ECS::TypeIndex Forward declare a bunch of classes (including Internal) Create a function called GetTypeIndex The function GetTypeIndex\u0026lt;T\u0026gt;() will return a unique type index for every type.\nComponent Header File # The next file is called Component.h, which contains the class declarations for component classes.\n#pragma once #include \u0026#34;Core/Engine/ECS/Common.h\u0026#34; namespace Nui::ECS { namespace Internal { struct ComponentContainerBase { virtual ~ComponentContainerBase() = default; virtual void OnRemove(Entity* entity) = 0; }; template \u0026lt;typename T\u0026gt; struct ComponentContainer : public ComponentContainerBase { T m_data; ComponentContainer() = default; ComponentContainer(const T\u0026amp; data) : m_data(data) {} protected: virtual void OnRemove(Entity* entity) override; }; } template \u0026lt;typename T\u0026gt; class ComponentHandle { public: ComponentHandle() : m_component(nullptr) {} ComponentHandle(T* component) : m_component(component) {} bool IsValid() const noexcept { return m_component != nullptr; } T\u0026amp; Get() const noexcept { return *m_component; } T* operator-\u0026gt;() const { return m_component; } operator bool() const { return IsValid(); } private: T* m_component; }; } Component Container Base # ComponentContainerBase is an internal abstract base struct for component containers, containing a virtual destructor and an abstract OnRemove function that is called on the container when an entity is removed\nComponent Container # ComponentContainer is an internal struct that derives from the Component Container Base. This struct contains a m_data member, which is the actual content of the component.\nComponent Handle # ComponentHandle is an accessor/wrapper class around a the component data (from the ComponentContainer)\nThe Entity Header File # The Entity.h file contains a couple classes, we will start by looking at the the Entity class first.\nThe Entity Class # The Entity class is how we will represent each entity in the ECS framework. To create and Entity, we meed to provide it (the constructor) the ECS context and the entity id.\n#pragma once #include \u0026#34;Core/Engine/ECS/Component.h\u0026#34; namespace Nui::ECS { class Entity { friend class Context; public: constexpr static U64 InvalidId = 0; using ComponentMap = std::unordered_map\u0026lt;TypeIndex, std::unique_ptr\u0026lt;Internal::ComponentContainerBase\u0026gt;\u0026gt;; public: Entity(Context* context, U64 id) : m_context(context), m_id(id) {} ~Entity() { RemoveAll(); } inline Context* GetContext() const noexcept { return m_context; } inline U64 GetId() const noexcept { return m_id; } inline bool IsPendingDestroy() const noexcept { return m_pendingDestroy; } template\u0026lt;typename T\u0026gt; bool Has() const template\u0026lt;typename T, typename... Args\u0026gt; ComponentHandle\u0026lt;T\u0026gt; Add(Args\u0026amp;\u0026amp;... args); template\u0026lt;typename T\u0026gt; ComponentHandle\u0026lt;T\u0026gt; Get(); template\u0026lt;typename T\u0026gt; bool Remove(); void RemoveAll(); template\u0026lt;typename... Types\u0026gt; bool With(typename std::common_type\u0026lt;std::function\u0026lt;void(ComponentHandle\u0026lt;Types\u0026gt;...)\u0026gt;\u0026gt;::type func) private: ComponentMap m_components; Context* m_context; U64 m_id; bool m_pendingDestroy{ false }; }; } The ComponentMap maps component type indices to unique pointers to component containers.\nThe Entity class has:\nGetter functions Function to check if the entity is marked to be destroyed at the end of frame Functions to operate on/with components Members: A map of component containers The ECS context The Entity id A boolean to check if entity is pending destruction Iterators # The Entity.h file contains additional iterator classes that assist in iteration over components of an Entity.\nEntity Component Iterator # EntityComponentIterator is an iterator class to allow easy iteration over entities with components.\nnamespace ECS::Internal { template \u0026lt;typename... Types\u0026gt; class EntityComponentIterator { public: EntityComponentIterator(Context* context, U64 index, bool isEnd, bool includePendingDestroy); inline U64 GetIndex() const noexcept { return m_index; } inline bool IncludePendingDestroy() const noexcept { return m_includePendingDestroy; } inline Context* GetContext() const noexcept { return m_context; } bool IsEnd() const noexcept; Entity* GetEntity() const noexcept; Entity* operator*() const noexcept bool operator==(const EntityComponentIterator\u0026lt;Types...\u0026gt;\u0026amp; other) const bool operator!=(const EntityComponentIterator\u0026lt;Types...\u0026gt;\u0026amp; other) const EntityComponentIterator\u0026lt;Types...\u0026gt;\u0026amp; operator++(); private: bool m_isEnd; U64 m_index; Context* m_context; bool m_includePendingDestroy; }; } Entity Component View # EntityComponentView is a class to represent a (non-owning) view over a range of entities in an ECS Context.\nnamespace ECS::Internal { template\u0026lt;typename... Types\u0026gt; class EntityComponentView { public: EntityComponentView(const EntityComponentIterator\u0026lt;Types...\u0026gt;\u0026amp; first, const EntityComponentIterator\u0026lt;Types...\u0026gt;\u0026amp; last); const EntityComponentIterator\u0026lt;Types...\u0026gt;\u0026amp; begin() const { return m_first; } const EntityComponentIterator\u0026lt;Types...\u0026gt;\u0026amp; end() const { return m_last; } private: EntityComponentIterator\u0026lt;Types...\u0026gt; m_first; EntityComponentIterator\u0026lt;Types...\u0026gt; m_last; }; } Entity Iterator # Entity Iterator class supports easy iteration over entities\nnamespace ECS::Internal { class EntityIterator { public: EntityIterator(Context* context, U64 index, bool isEnd, bool includePendingDestroy); bool IsEnd() const noexcept; inline U64 GetIndex() const noexcept { return m_index; } inline bool IncludePendingDestroy() const noexcept { return m_includePendingDestroy; } inline Context* GetContext() const noexcept { return m_context; } Entity* GetEntity() const noexcept; Entity* operator*() const noexcept { return GetEntity(); } bool operator==(const EntityIterator\u0026amp; other) const bool operator!=(const EntityIterator\u0026amp; other) const EntityIterator\u0026amp; operator++(); private: bool m_isEnd; U64 m_index; Context* m_context; bool m_includePendingDestroy; }; } Entity View # EntityView class is used to represent a view over a range of entities in an ECS Context.\nnamespace ECS::Internal { class EntityView { public: EntityView(const EntityIterator\u0026amp; first, const EntityIterator\u0026amp; last) : m_first(first), m_last(last) { if (m_first.GetEntity() == nullptr || m_first.GetEntity()-\u0026gt;IsPendingDestroy() \u0026amp;\u0026amp; !m_first.IncludePendingDestroy()) { ++m_first; } } const EntityIterator\u0026amp; begin() const { return m_first; } const EntityIterator\u0026amp; end() const { return m_last; } private: EntityIterator m_first; EntityIterator m_last; }; } You can notice a patterm here. Every type of iterator class has a view class along with it. The iterator class allowing the ECS Context/Systems to iterate over the entities and thier components. The views are used to access the underlying iterator.\nThe Event System # One of the features of this ECS framework is how it includes an event system built into it - Systems created for the ECS can make use of this event system. This section describes how the event system is designed.\nEvent Subscriber # Systems that want to participate in the ECS event system, need to inherit from the EventSubscriber class, which inherits from the EventSubscriberBase class.\nnamespace Nui::ECS { namespace Internal { class EventSubscriberBase { public: virtual ~EventSubscriberBase() = default; }; } template \u0026lt;typename T\u0026gt; class EventSubscriber : public Internal::EventSubscriberBase { public: virtual ~EventSubscriber() = default; virtual void OnEvent(Context* context, const T\u0026amp; event) = 0; }; } The EventSubscriber class is templated and contains a pure virtual function called OnEvent, which allows the user to pass in custom event types.\nEach event is declared as a struct and is passed as the event argument for the OnEvent function along with the ECS Context.\nECS Events # The ECS framework contains some built-in functions that the Systems can use, and are automatically dispatched by the ECS Context.\nnamespace Events { struct OnEntityCreate { Entity* Entity; }; struct OnEntityDestroy { Entity* Entity; }; template \u0026lt;typename T\u0026gt; struct OnComponentAdd { Entity* Entity; ComponentHandle\u0026lt;T\u0026gt; Component; }; template \u0026lt;typename T\u0026gt; struct OnComponentRemove { Entity* Entity; ComponentHandle\u0026lt;T\u0026gt; Component; }; } The user can create custom events as structs and make use of the EventSubscriber\u0026lt;T\u0026gt; class to dispatch the event\nSystems # Systems is what I want the user to be working with when writing their own code. Nui Engine will have some built in systems (for example systems to update the transform, dispatch draw commands, etc.) that will be registered on initialization.\n#pragma once #include \u0026#34;Core/Engine/ECS/Common.h\u0026#34; namespace Nui::ECS { class SystemBase { public: virtual ~SystemBase() = default; virtual void OnInit(Context* ctx) {} virtual void OnUpdate(Context* ctx, const F64 dt) {} virtual void OnShutdown(Context* ctx) {} bool IsEnabled() const noexcept { return m_enabled; } void SetIsEnabled(bool enabled) noexcept { m_enabled = enabled; } private: bool m_enabled{ true }; }; } ECS Context # Throughtout this article, I\u0026rsquo;ve been talking about the ECS Context, what is it?\nThe Context is a class that handles and manages all entities, components and systems. Consider it like an ECS manager.\nHere is the Context class:\n#pragma once #include \u0026#34;Core/Engine/ECS/Common.h\u0026#34; #include \u0026lt;concepts\u0026gt; namespace Nui::ECS { template \u0026lt;typename T\u0026gt; concept IsSystem = std::is_base_of\u0026lt;SystemBase, T\u0026gt;::value; class Context { public: using SubscriberMap = std::unordered_map\u0026lt;TypeIndex, std::vector\u0026lt;Internal::EventSubscriberBase*\u0026gt;, std::hash\u0026lt;TypeIndex\u0026gt;, std::equal_to\u0026lt;TypeIndex\u0026gt;\u0026gt;; public: Context(); virtual ~Context(); inline U64 GetEntityCount() const noexcept { return m_entities.size(); } Entity* GetEntityById(U64 id); Entity* GetEntityByIndex(U64 index); Entity* CreateEntity(); void DestroyEntity(Entity* e, bool immediate = false); bool ClearPending(); void Reset(); template \u0026lt;typename T, typename... Args\u0026gt; T* RegisterSystem(Args\u0026amp;\u0026amp;... args) requires IsSystem\u0026lt;T\u0026gt;; template \u0026lt;typename T\u0026gt; void UnregisterSystem() requires IsSystem\u0026lt;T\u0026gt;; void UnregisterAllSystems(); template \u0026lt;typename T\u0026gt; T* GetSystem() requires IsSystem\u0026lt;T\u0026gt;; template \u0026lt;typename T\u0026gt; void EnableSystem() requires IsSystem\u0026lt;T\u0026gt;; template \u0026lt;typename T\u0026gt; void DisableSystem() requires IsSystem\u0026lt;T\u0026gt;; template \u0026lt;typename T\u0026gt; bool IsSystmEnabled() requires IsSystem\u0026lt;T\u0026gt;; template \u0026lt;typename T\u0026gt; void SubscribeEvent(EventSubscriber\u0026lt;T\u0026gt;* subscriber); template\u0026lt;typename T\u0026gt; void UnsubscribeEvent(EventSubscriber\u0026lt;T\u0026gt;* subscriber); void UnsubscribeAll(void* subscriber); template\u0026lt;typename T\u0026gt; void EmitEvent(const T\u0026amp; event); template\u0026lt;typename... Types\u0026gt; Internal::EntityComponentView\u0026lt;Types...\u0026gt; Each(bool includePendingDestroy = false); template\u0026lt;typename... Types\u0026gt; void Each(typename std::common_type\u0026lt;std::function\u0026lt;void(Entity*, ComponentHandle\u0026lt;Types\u0026gt;...)\u0026gt;\u0026gt;::type viewFunc, bool includePendingDestroy = false); Internal::EntityView All(bool includePendingDestroy = false); void All(std::function\u0026lt;void(Entity*)\u0026gt; viewFunc, bool includePendingDestroy = false); void Tick(const F64 dt); private: std::vector\u0026lt;std::unique_ptr\u0026lt;Entity\u0026gt;\u0026gt; m_entities; std::vector\u0026lt;std::unique_ptr\u0026lt;SystemBase\u0026gt;\u0026gt; m_systems; SubscriberMap m_subscribers; U64 m_lastEntityId{ 0 }; }; } The Context class has the following functionality:\nGet the total entities in the context Get Entity (class) by id Get Entity (class) by index (from the entites collection) Create an Entity Destroy and Entity Clear all entities that are marked to be destroyed Reset deletes all entities and their components but keeps the systems Functions to operate on Systems (makes use of the IsSystem concept) Functions to make use of the ECS event system Functions to iterate over the entities with components Function to update the ECS Context every frame (Tick()) Using The Nui ECS Framework # Creating A Custom System # Here is a quick demo on how to make use of the ECS framework described above. Starting with creating a System.\nCreate a custom component\nstruct TestComponent { int x = -1; int y = -1; }; Create a custom event\nstruct TestEvent { int value; }; Create a custom system\n/* Inheritance Details * - Inherit from SystemBase to mark this class as a ECS System * - Inherit from EventSubscriber\u0026lt;T\u0026gt; to be able to consume the following events: * - OnEntityCreate (built-in event) * - OnEntityDestroy (built-in event) * - OnComponentAdd\u0026lt;TestComponent\u0026gt; (built-in templated event) * - OnComponentRemove\u0026lt;TestComponent\u0026gt; (built-in templated event) * - TestEvent (custom user component) */ class TestSystem : public Nui::ECS::SystemBase, public Nui::ECS::EventSubscriber\u0026lt;Nui::ECS::Events::OnEntityCreate\u0026gt;, public Nui::ECS::EventSubscriber\u0026lt;Nui::ECS::Events::OnEntityDestroy\u0026gt;, public Nui::ECS::EventSubscriber\u0026lt;Nui::ECS::Events::OnComponentAdd\u0026lt;TestComponent\u0026gt;\u0026gt;, public Nui::ECS::EventSubscriber\u0026lt;Nui::ECS::Events::OnComponentRemove\u0026lt;TestComponent\u0026gt;\u0026gt;, public Nui::ECS::EventSubscriber\u0026lt;TestEvent\u0026gt; { public: virtual ~TestSystem() {} // Called when system is initialized virtual void OnInit(Nui::ECS::Context* ctx) { // Register all events on initialization ctx-\u0026gt;SubscribeEvent\u0026lt;Nui::ECS::Events::OnEntityCreate\u0026gt;(this); ctx-\u0026gt;SubscribeEvent\u0026lt;Nui::ECS::Events::OnEntityDestroy\u0026gt;(this); ctx-\u0026gt;SubscribeEvent\u0026lt;Nui::ECS::Events::OnComponentAdd\u0026lt;TestComponent\u0026gt;\u0026gt;(this); ctx-\u0026gt;SubscribeEvent\u0026lt;Nui::ECS::Events::OnComponentRemove\u0026lt;TestComponent\u0026gt;\u0026gt;(this); ctx-\u0026gt;SubscribeEvent\u0026lt;TestEvent\u0026gt;(this); } // Called every frame virtual void OnUpdate(Nui::ECS::Context* ctx, const Nui::F64 dt) { // Change all entities with test component values to 1 ctx-\u0026gt;Each\u0026lt;TestComponent\u0026gt;( [\u0026amp;](Nui::ECS::Entity* e, Nui::ECS::ComponentHandle\u0026lt;TestComponent\u0026gt; comp) { comp-\u0026gt;X = 1; comp-\u0026gt;Y = 1; }); } // We need to unsubscribe this from the event system virtual void OnShutdown(Nui::ECS::Context* ctx) { ctx-\u0026gt;UnsubscribeAll(this); } virtual void OnEvent(class Nui::ECS::Context* ctx, const Nui::ECS::Events::OnEntityCreate\u0026amp; event) override { // Called whenever a new entity is created } virtual void OnEvent(class Nui::ECS::Context* ctx, const Nui::ECS::Events::OnEntityDestroy\u0026amp; event) override { // Called whenever a new entity is destroyed } virtual void OnEvent(class Nui::ECS::Context* ctx, const Nui::ECS::Events::OnComponentAdd\u0026lt;TestComponent\u0026gt;\u0026amp; event) override { // Called whenever a new TestComponent is added to an entity } virtual void OnEvent(class Nui::ECS::Context* ctx, const Nui::ECS::Events::OnComponentRemove\u0026lt;TestComponent\u0026gt;\u0026amp; event) override { // Called whenever a new TestComponent is removed from an entity } virtual void OnEvent(class Nui::ECS::Context* ctx, const TestEvent\u0026amp; event) override { // Called whenever a new the TestEvent is dispatched } }; Using The ECS Context # Now that we have an ECS System, we can make use of it using the ECS Context\nCreate a new ECS Context pointer\nstd::unique_ptr\u0026lt;ECS::Context\u0026gt; ctx = std::make_unique\u0026lt;ECS::Context\u0026gt;(); Register the system\nTestSystem* system = ctx-\u0026gt;RegisterSystem\u0026lt;TestSystem\u0026gt;(); Add 10 entities with the TestComponent\nfor (I32 i = 0; i \u0026lt; 10; i++) { ECS::Entity* e = ctx-\u0026gt;CreateEntity(); e-\u0026gt;Add\u0026lt;TestComponent\u0026gt;(TestComponent{ 0, 0 }); } Update the Context every frame\nctx-\u0026gt;Tick(deltaTime); You can loop over the entities in two different ways\n// --- METHOD 1: Using the foreach loop--- for (ECS::Entity* e : ctx-\u0026gt;Each\u0026lt;TestComponent\u0026gt;()) { ECS::ComponentHandle\u0026lt;TestComponent\u0026gt; comp = e-\u0026gt;Get\u0026lt;TestComponent\u0026gt;(); // Operate on component comp-\u0026gt;X = 2; comp-\u0026gt;Y = 2; } // --- METHOD 2: Using the Context::Each\u0026lt;\u0026gt; function--- ctx-\u0026gt;Each\u0026lt;TestComponent\u0026gt;( [\u0026amp;](Nui::ECS::Entity* e, Nui::ECS::ComponentHandle\u0026lt;TestComponent\u0026gt; comp) { // Operate on component comp-\u0026gt;X = 2; comp-\u0026gt;Y = 2; }); You can dispatch events using the Context::EmitEvent function. Also allowing you to construc the event struct in place\n// Set the TestEvent::value to 5 ctx-\u0026gt;EmitEvent\u0026lt;TestEvent\u0026gt;(TestEvent{ 5 }); Conclusion # With the ECS system now done, we will next work on the World class, which will handle and manage our ECS Context. Basically a manager for a manager (weird IKR!)\nI know this article isn\u0026rsquo;t as detailed as the other posts. This article was already too long and if I had to explain every function in every ECS class, we would be on ECS for the next three articles.\nProgramming Game Engine C++ ECS ","date":null,"permalink":"/posts/mage7/","section":"Posts","summary":"Making a Game Engine - Part 7 - Entity Component System","title":"MAGE - Part 7"},{"content":" Finally! Something on the screen! Check out Nui Engine on Github Up to this point, when we run the program nothing happens. In fact it technically should not compile since we have not yet defined the main function of the program. So that\u0026rsquo;s what we will get to in this post.\nThis article shows usage of custom utility classes/functions such as Singleton and Timer that I will not be going into detail in these posts. If you want to see their implementation, head over to the github repository.\nEntry Point # In Nui Engine, for the end user, I do not want the user to describe the entry point (main/WinMain function). That should be present in the NuiCore itself.\nFirst I will create a new file called EntryPoint.h in the NuiCore project with the WinMain function:\nint WINAPI wWinMain( _In_ HINSTANCE hInstance, _In_opt_ HINSTANCE hPrevInstance, _In_ LPWSTR lpCmdLine, _In_ int nShowCmd ) { return 0; } We will come back to this file later. For now, Let\u0026rsquo;s make the base application class\nApplication Base # Every user application class will derive from this base class which will handle internal initialization. So here is the back-bone of the AppBase class:\n// In Core/Application/AppBase.h namespace Nui { class AppBase : public Window { friend class Engine; public: explicit AppBase(WStringView appName, Window::Style style, Window::Size size); virtual ~AppBase() = default; virtual void OnInit() {} virtual void OnShutdown() {} private: AppBase(const AppBase\u0026amp;) = delete; AppBase(AppBase\u0026amp;\u0026amp;) = delete; void Tick(F64 dt); }; namespace Internal { extern std::unique_ptr\u0026lt;Nui::AppBase\u0026gt; MakeApp(); } } #define NUI_DECLARE_APP(app, ...) \\ namespace Nui::Internal \\ { \\ std::unique_ptr\u0026lt;Nui::AppBase\u0026gt; MakeApp() \\ { \\ return std::make_unique\u0026lt;app\u0026gt;(__VA_ARGS__);\\ } \\ } As you can see the AppBase class inherits from the Window class. Allowing the user, when they inherit their application from this class, they can configure the type of window they want their application to have.\nDecalaring An Application # Of course when you create an application, you need some way to create it. That\u0026rsquo;s where the extern (internal) function MakeApp comes in. Along with the macro NUI_DECLARE_APP. By declaring a function extern you tell the compiler that this function will exist. Just not now. But somewhere in the codebase, later on. If this does not make sense. Just keep reading and all these things will start connecting :)\nThe Engine Class # Next up is the engine class. The Engine is running for the entire lifetime of the application. In fact it is what initializes and shuts down the application. For now it will have a simple header with a unique pointer to the application class.\n// In Core/Engine.h namespace Nui { class Engine { public: Engine(); ~Engine(); void Run(); void Quit(); inline F64 GetEngineUpTime() const noexcept { return m_engineTimer.GetElapsedSeconds(); } AppBase* GetApp() const noexcept; private: std::unique_ptr\u0026lt;AppBase\u0026gt; m_app; bool m_isRunning; Timer m_engineTimer; }; } Engine Initialization # In the constructor of the engine class we will open the log file and make the application (for now). For fun I also like to have timers for my initialization and shutdown functions to show how long it takes. Here you can see the use of the MakeApp extern (internal) function I defined when making the AppBase class above.\nEngine::Engine() : m_isRunning(true) { // Start engine up timer m_engineTimer.Start(); Timer timer; timer.Start(); // Open engine log file Log::Internal::OpenLogFile(Filesystem::GetCurrentWorkingDirectory() / \u0026#34;Saved\u0026#34; / \u0026#34;NuiEngine.log\u0026#34;); NUI_LOG(Debug, Engine, \u0026#34;Initializing Nui Engine...\u0026#34;); // Make application m_app = Internal::MakeApp(); NUI_ASSERT(m_app.get(), \u0026#34;Failed to create application\u0026#34;); timer.Stop(); NUI_LOG(Debug, Engine, \u0026#34;Nui Engine initialized successfully in \u0026#34;, timer.GetElapsedSeconds().ToString(), \u0026#34; seconds\u0026#34;); } Engine Shudown # Similar to the constructor which does the initialization, I have the destructor which handles the engine shutdown procedure. Here, for now, we will simply reset the application unique pointer, which will call the destructor of the application.\nEngine::~Engine() { Timer timer; timer.Start(); NUI_LOG(Debug, Engine, \u0026#34;Shutting down Nui Engine...\u0026#34;); // Shutdown the application m_app.reset(); timer.Stop(); m_engineTimer.Stop(); NUI_LOG(Debug, Engine, \u0026#34;Nui Engine shut down successfully in \u0026#34;, timer.GetElapsedSeconds().ToString(), \u0026#34; seconds\u0026#34;); NUI_LOG(Debug, Engine, \u0026#34;Nui Engine was active for \u0026#34;, m_engineTimer.GetElapsedSeconds().ToString(), \u0026#34; seconds\u0026#34;); Log::Internal::CloseLogFile(); } Running The Engine # The engine Run function is where the main update loop of the entire application will be. Before the while loop, we will call the application OnInit and after the while loop we will call the OnShutdown on our application. insode the while loop we will process the Win32 window messages, update input, calculate delta/frame time and then update the application using the Tick function.\nvoid Engine::Run() { m_app-\u0026gt;OnInit(); Timer updateLoop; updateLoop.Start(); F64 now = 0.0, dt = 0.0, elapsed = 0.0; while (m_isRunning \u0026amp;\u0026amp; !m_app-\u0026gt;WantsToClose()) { now = updateLoop.GetElapsedSeconds(); Input::Internal::Update(); [[unlikely]] // Will only happen on the first frame so we can mark this branch as \u0026#39;unlikely\u0026#39; if (dt == 0.0f) { continue; // Skip update on the first frame } // Update application m_app-\u0026gt;Tick(dt); dt = now - elapsed; elapsed = now; } updateLoop.Stop(); m_app-\u0026gt;OnShutdown(); } Updating Entry Point # Now that we have all the classes we need, we can go back to EntryPoint.h and modify the WinMain function to run the Engine class. Here I am making the Engine class a singleton which allows me to access anything I need using the Singleton\u0026lt;\u0026gt; template class. But this can be a global or local variable if preferred.\nint WINAPI wWinMain( _In_ HINSTANCE hInstance, _In_opt_ HINSTANCE hPrevInstance, _In_ LPWSTR lpCmdLine, _In_ int nShowCmd ) { try { Nui::Singleton\u0026lt;Nui::Engine\u0026gt;::Get().Run(); Nui::Singleton\u0026lt;Nui::Engine\u0026gt;::Destroy(); } catch (const std::exception\u0026amp; e) { NUI_LOG(Exception, Main, e.what()); } return 0; } User Code # For testing the code, I have made a new project called Testbench. This is where we will be testing all our code for this engine. In this project I create an application class (this is the user application) called TestbenchApp that derives from our previously made AppBase class.\n// In Testbench/TestApp.h #pragma once #include \u0026lt;Core/App/AppBase.h\u0026gt; class TestbenchApp : public Nui::AppBase { public: TestbenchApp(); virtual ~TestbenchApp(); void OnInit() override; void OnShutdown() override; }; In the cpp file we will create the implementation of the above functions, for now the OnInit and OnShutdown functions are empty (apart from the log message that they were called)\n// In Testbench/TestApp.cpp #include \u0026#34;TestApp.h\u0026#34; TestbenchApp::TestbenchApp() : Nui::AppBase(L\u0026#34;TestbenchApp\u0026#34;, Nui::Window::Style::Windowed, { 1280, 720 }) { } TestbenchApp::~TestbenchApp() { } void TestbenchApp::OnInit() { NUI_LOG(Info, TestbenchApp, \u0026#34;Initializing Testbench App\u0026#34;); } void TestbenchApp::OnShutdown() { NUI_LOG(Info, TestbenchApp, \u0026#34;Shutting down Testbench App\u0026#34;); } And finally we can create a new file called Main.cpp, where we will include EntryPoint.h from the Core project and declare our application.\n// In Testbench/Main.cpp #include \u0026lt;Core/EntryPoint.h\u0026gt; #include \u0026#34;Testbench/TestApp.h\u0026#34; NUI_DECLARE_APP(TestbenchApp) Conclusion # If the above steps were followed, now when you compile and run the program, you should have a window pop up. Which means that we finally have something on the screen! In the next post I will go over custom ECS + event system for our game engine. See ya there üëã.\nProgramming Game Engine C++ ","date":null,"permalink":"/posts/mage6/","section":"Posts","summary":"Making a Game Engine - Part 6 - Application Entry Point","title":"MAGE - Part 6"},{"content":" Capturing the keys (and clicks) to success! Check out Nui Engine on Github In the previous post, I went over setting up the base for the input system. In this one we\u0026rsquo;ll see how I implemented processing Win32 input events.\nImplementing the Input API # I made a new file called Input.h and made the API functions for the input system\nnamespace Nui { namespace Input { namespace Internal { [[nodiscard]] bool ProcessInputWndProc(HWND hWnd, UINT uMsg, WPARAM wParam, LPARAM lParam); void Update(); } [[nodiscard]] const Mouse::Point\u0026amp; GetMousePosition(); [[nodiscard]] const Mouse::Point\u0026amp; GetMouseRawDelta(); [[nodiscard]] const Mouse::WheelInfo\u0026amp; GetMouseWheelH(); [[nodiscard]] const Mouse::WheelInfo\u0026amp; GetMouseWheelV(); [[nodiscard]] const Mouse::ButtonState\u0026amp; GetMouseButton(Mouse::Button btn); [[nodiscard]] const Mouse::ButtonState\u0026amp; GetMouseButton(U32 btn); [[nodiscard]] const Keyboard::KeyState\u0026amp; GetKeyState(KeyCode key); } } In the cpp file I have the Keyboard and Mouse as static unique pointers along with a bunch of helper functions (that I\u0026rsquo;ll cover later)\n// In Input.cpp static bool s_initialized{ false }; static std::unique_ptr\u0026lt;Mouse\u0026gt; s_mouse{ nullptr }; static std::unique_ptr\u0026lt;Keyboard\u0026gt; s_keyboard{ nullptr }; Constructors # From the Keyboard and Mouse structures made in the last post, each had a constexpr constructor, which we can use to initialize thier internal state.\nStarting with the simple mouse constructor:\nconstexpr Mouse::Mouse() : Position() , RawDelta() , WheelH() , WheelV() { ButtonStates[0] = ButtonState(Mouse::Button::Left); ButtonStates[1] = ButtonState(Mouse::Button::Right); ButtonStates[2] = ButtonState(Mouse::Button::Middle); ButtonStates[3] = ButtonState(Mouse::Button::MouseX1); ButtonStates[4] = ButtonState(Mouse::Button::MouseX2); } Followed by an annoyingly large Keyboard constructor (shortened for this post):\nconstexpr Keyboard::Keyboard() { KeyStates[ConvertKeyCodeToArrayIndex(KeyCode::LeftArrow)] = KeyState(KeyCode::LeftArrow); KeyStates[ConvertKeyCodeToArrayIndex(KeyCode::RightArrow)] = KeyState(KeyCode::RightArrow); KeyStates[ConvertKeyCodeToArrayIndex(KeyCode::UpArrow)] = KeyState(KeyCode::UpArrow); . . . KeyStates[ConvertKeyCodeToArrayIndex(KeyCode::NumPadMultiply)] = KeyState(KeyCode::NumPadMultiply); KeyStates[ConvertKeyCodeToArrayIndex(KeyCode::NumPadSubtract)] = KeyState(KeyCode::NumPadSubtract); KeyStates[ConvertKeyCodeToArrayIndex(KeyCode::NumPadAdd)] = KeyState(KeyCode::NumPadAdd); } Input Window Procedure # The first thing to do in the input system is to capture the Win32 messages. And since I am using a namespace, it was quite easy to hook into the the window procedure I made in the last post.\nLRESULT Window::MessageHandler(HWND hWnd, UINT uMsg, WPARAM wParam, LPARAM lParam) { // Existing code if (Input::Internal::ProcessInputWndProc(hWnd, uMsg, wParam, lParam)) { // Message was processed by input system return 0; } // Return default window procedure } Initializing the Input System # Using the static bool declared above we can initialize the input system on the first function call (like a do-once function). So inside the input window procedure, I create the mouse and keyboard objects and register raw mouse input using MSDN as reference.\n// If input system has not been initialized, register raw input devices but don\u0026#39;t process input [[unlikely]] if (!s_initialized) { s_mouse = std::make_unique\u0026lt;Mouse\u0026gt;(); s_keyboard = std::make_unique\u0026lt;Keyboard\u0026gt;(); // Register for raw input RAWINPUTDEVICE Rid[1]; Rid[0].usUsagePage = HID_USAGE_PAGE_GENERIC; Rid[0].usUsage = HID_USAGE_GENERIC_MOUSE; Rid[0].dwFlags = RIDEV_INPUTSINK; Rid[0].hwndTarget = hWnd; if (!RegisterRawInputDevices(Rid, 1, sizeof(Rid[0]))) { // Log error } // Consider input initialized even if registration failed (it\u0026#39;s not fatal) s_initialized = true; return false; } Mouse Input # Capturing Raw Input # After registering the raw mouse device, we can use the WM_INPUT to get the raw mouse data and store it in our mouse structure.\ncase WM_INPUT: { U32 dwSize = sizeof(RAWINPUT); static BYTE lpb[sizeof(RAWINPUT)]; ::GetRawInputData((HRAWINPUT)lParam, RID_INPUT, lpb, \u0026amp;dwSize, sizeof(RAWINPUTHEADER)); RAWINPUT* raw = (RAWINPUT*)lpb; [[likely]] if (raw \u0026amp;\u0026amp; raw-\u0026gt;header.dwType == RIM_TYPEMOUSE) { NUI_ASSERT((bool)s_mouse, \u0026#34;Mouse is not initialized\u0026#34;); [[likely]] if (s_mouse) { s_mouse-\u0026gt;RawDelta.X = raw-\u0026gt;data.mouse.lLastX; s_mouse-\u0026gt;RawDelta.Y = raw-\u0026gt;data.mouse.lLastY; } } return true; } Capturing Mouse Position # This one is quite easy where where we can simply capture the WM_MOUSEMOVE message to get the mouse position relative to the client window.\ncase WM_MOUSEMOVE: { if (s_mouse) { POINTS p = MAKEPOINTS(lParam); s_mouse-\u0026gt;Position.X = p.x; s_mouse-\u0026gt;Position.Y = p.y; } return true; } Capturing Mouse Wheel # Using the WM_MOUSEWHEEL and WM_MOUSEHWHEEL messages along with the GET_WHEEL_DELTA_WPARAM() to get the wheel movement direction/delta. I also have a helper function called GetModifiers() to get the modifier keys that were pressed when the mouse wheel message is received.\ncase WM_MOUSEWHEEL: { if (s_mouse) { s_mouse-\u0026gt;WheelV.Delta = GET_WHEEL_DELTA_WPARAM(wParam); s_mouse-\u0026gt;WheelV.Modifier = GetModifiers(); POINTS p = MAKEPOINTS(lParam); s_mouse-\u0026gt;WheelV.Position.X = p.x; s_mouse-\u0026gt;WheelV.Position.Y = p.y; } return true; } case WM_MOUSEHWHEEL: { if (s_mouse) { s_mouse-\u0026gt;WheelH.Delta = GET_WHEEL_DELTA_WPARAM(wParam); s_mouse-\u0026gt;WheelH.Modifier = GetModifiers(); POINTS p = MAKEPOINTS(lParam); s_mouse-\u0026gt;WheelH.Position.X = p.x; s_mouse-\u0026gt;WheelH.Position.Y = p.y; } return true; } Capturing Mouse Button States # One of the helper functions I made was to process mouse button states, here is the function\nbool ProcessMouseButton(Mouse::Button btn, bool pressed, LPARAM lParam) { if (s_mouse) { POINTS p = MAKEPOINTS(lParam); s_mouse-\u0026gt;Position.X = p.x; s_mouse-\u0026gt;Position.Y = p.y; Mouse::ButtonState\u0026amp; state = s_mouse-\u0026gt;ButtonStates[Mouse::ConvertMouseButtonToArrayIndex(btn)]; NUI_ASSERT(state.Btn == btn, \u0026#34;Input button and mouse state button mismatch!\u0026#34;); state.Modifier = GetModifiers(); if (pressed) { if (!state.IsHeld) { state.IsPressed = true; state.IsHeld = true; state.IsReleased = false; } else { // Button was not pressed this frame state.IsPressed = false; // Set pressed to false if the button is already held } } else { state.IsPressed = false; state.IsHeld = false; state.IsReleased = true; } return true; } return false; } Here I first get the mouse position whenever the mouse button is pressed. If the button was pressed this frame then I set the pressed and held value to true and released to false provided the button is not being held (pressed in a previous frame). If the button is not being pressed then I set the pressed and held to false and released to true.\nI will be using the same logic for keyboard input to set key states\nAfter that we can use this function in the input window procedure:\ncase WM_LBUTTONDOWN: return ProcessMouseButton(Mouse::Button::Left, true, lParam); case WM_MBUTTONDOWN: return ProcessMouseButton(Mouse::Button::Middle, true, lParam); case WM_RBUTTONDOWN: return ProcessMouseButton(Mouse::Button::Right, true, lParam); case WM_LBUTTONUP: return ProcessMouseButton(Mouse::Button::Left, false, lParam); case WM_MBUTTONUP: return ProcessMouseButton(Mouse::Button::Middle, false, lParam); case WM_RBUTTONUP: return ProcessMouseButton(Mouse::Button::Right, false, lParam); case WM_XBUTTONDOWN: { Mouse::Button btn = (HIWORD(wParam) == XBUTTON1) ? Mouse::Button::MouseX1 : Mouse::Button::MouseX2; return ProcessMouseButton(btn, true, lParam); } case WM_XBUTTONUP: { Mouse::Button btn = (HIWORD(wParam) == XBUTTON1) ? Mouse::Button::MouseX1 : Mouse::Button::MouseX2; return ProcessMouseButton(btn, false, lParam); } Keyboard Input # Capturing Key States # Windows only gives two top level types of key state information, whether the key was pressed this frame (key down) or the key was released this frame (key up). Each of these messages are of two types: keyboard keys and system keys. We can capture them using WM_SYSKEYDOWN, WM_KEYDOWN, WM_SYSKEYUP and WM_KEYUP messages.\nFor processing key down messages:\ncase WM_SYSKEYDOWN: [[fallthrough]]; case WM_KEYDOWN: { NUI_ASSERT((bool)s_keyboard, \u0026#34;Keyboard is not initialized\u0026#34;); [[likely]] if ((U64)wParam \u0026lt; 256) { // Process some modifiers early if (ProcessKeyboard(wParam, true)) return true; Keyboard::KeyState\u0026amp; state = s_keyboard-\u0026gt;KeyStates[ConvertKeyCodeToArrayIndex((KeyCode)wParam)]; NUI_ASSERT(state.Key == KeyCode(wParam), \u0026#34;WPARAM is not a KeyCode\u0026#34;); if (!state.IsHeld) { state.IsPressed = true; state.IsHeld = true; state.IsReleased = false; } else { state.IsPressed = false; // Set pressed to false if the key is already held } state.Modifier = GetModifiers(); return true; } return false; } Similarly for key up messages\ncase WM_SYSKEYUP: [[fallthrough]]; case WM_KEYUP: { NUI_ASSERT((bool)s_keyboard, \u0026#34;Keyboard is not initialized\u0026#34;); [[likely]] if ((U64)wParam \u0026lt; 256) { // Process some modifiers early if (ProcessKeyboard(wParam, true)) return true; Keyboard::KeyState\u0026amp; state = s_keyboard-\u0026gt;KeyStates[ConvertKeyCodeToArrayIndex(KeyCode(wParam))]; NUI_ASSERT(state.Key == KeyCode(wParam), \u0026#34;WPARAM is not a KeyCode\u0026#34;); state.IsPressed = false; state.IsHeld = false; state.IsReleased = true; return true; } return false; } The above two code snippets are very similar to the mouse button state code. So I will not go in depth about explaining them. At the same time you must have noticed a function called ProcessKeyboard, this function is used to process some modifier keys early.\nProcessing Keyboard Modifiers # So this is weird function that does almost the same thing as the above code, but with a slight difference, it calculates which side of the modifier key was pressed (left or right).\nHere is complete function body, with explanations below:\nbool ProcessKeyboard(U64 vk, bool pressed) { bool handled = false; auto doVKDown = [\u0026amp;](U64 vk) { Keyboard::KeyState\u0026amp; state = s_keyboard-\u0026gt;KeyStates[ConvertKeyCodeToArrayIndex((KeyCode)VK_LSHIFT)]; if (!state.IsHeld) { state.IsPressed = true; state.IsHeld = true; state.IsReleased = false; } else { state.IsPressed = false; // Set pressed to false if the key is already held } state.Modifier = GetModifiers(); }; auto doVKUp = [\u0026amp;](U64 vk) { Keyboard::KeyState\u0026amp; state = s_keyboard-\u0026gt;KeyStates[ConvertKeyCodeToArrayIndex((KeyCode)VK_LSHIFT)]; state.IsPressed = false; state.IsHeld = false; state.IsReleased = true; state.Modifier = GetModifiers(); }; if (vk == VK_SHIFT) { if (IsVKPressed(VK_LSHIFT) == pressed) doVKDown(VK_LSHIFT); else doVKUp(VK_LSHIFT); if (IsVKPressed(VK_RSHIFT) == pressed) doVKDown(VK_RSHIFT); else doVKUp(VK_RSHIFT); handled = true; } if (vk == VK_CONTROL) { if (IsVKPressed(VK_LCONTROL) == pressed) doVKDown(VK_LCONTROL); else doVKUp(VK_LCONTROL); if (IsVKPressed(VK_RCONTROL) == pressed) doVKDown(VK_RCONTROL); else doVKUp(VK_RCONTROL); handled = true; } if (vk == VK_MENU) { if (IsVKPressed(VK_LMENU) == pressed) doVKDown(VK_LMENU); else doVKUp(VK_LMENU); if (IsVKPressed(VK_RMENU) == pressed) doVKDown(VK_RMENU); else doVKUp(VK_RMENU); handled = true; } return handled; } Here there are two lambdas called doVKUp and doVKDown. These lambdas perform the exact same logic as earlier to capture the key/mouse states. But the main job of the function of this function is to decide what key to call those functions for. That is decided by the if-chain below the lambdas.\nWithin each if statement, I first check for the \u0026rsquo;top-level\u0026rsquo; key code regarding what modifier key was pressed. Then using a helper function called IsVkPressed (explained later), I check if the key is being pressed or not, which decides which lambda is to be called for which side of the modifier key.\nHelper Functions # In this post you would have seen two functions that I refer to as \u0026lsquo;Helper Functions\u0026rsquo;. Here is what they are and what they do:\nIs Virtual Key Pressed # The first helper function is IVKPressed, this function is simply a wrapper around the Win32 function GetKeyState and checks if a virtual key is up or down.\nstatic bool IsVKPressed(I32 vk) { return (::GetKeyState(vk) \u0026amp; 0x8000) != 0; } Getting Key Modifiers # The other helper function that I use is the GetModifiers function. This function returns a Modifier enum. It makes use of the above IsVKPressed function to check for modifier keys\nstatic Modifier GetModifiers() { U64 m = 0; // Modifier::None if (IsVKPressed(VK_LSHIFT)) m |= Modifier::MOD_LShift; if (IsVKPressed(VK_RSHIFT)) m |= Modifier::MOD_RShift; if (IsVKPressed(VK_LCONTROL)) m |= Modifier::MOD_LControl; if (IsVKPressed(VK_RCONTROL)) m |= Modifier::MOD_RControl; if (IsVKPressed(VK_LMENU)) m |= Modifier::MOD_LAlt; if (IsVKPressed(VK_RMENU)) m |= Modifier::MOD_RAlt; if (IsVKPressed(VK_LWIN)) m |= Modifier::MOD_LSuper; if (IsVKPressed(VK_RWIN)) m |= Modifier::MOD_RSuper; return static_cast\u0026lt;Modifier\u0026gt;(m); } Updating The Input System # Although input messages will be recieved by the window thanks to the window message pump. But we want to manually be able to reset the internal input state of the entire keyboard and mouse (for example when the window loses focus).\nReset Input State # Here is the function that resets the internal input state of the keyboard and mouse by setting all members to their default values. It also takes a boolean in as an argument to check if we want to reset the held state of the keys/buttons as well (explained later).\nvoid Reset(bool resetHeld = false) { [[likely]] if (s_keyboard) // Reset keyboard { for (auto\u0026amp; state: s_keyboard-\u0026gt;KeyStates) { state.IsPressed = false; state.IsReleased = false; if (resetHeld) state.IsHeld = false; } } [[likely]] if (s_mouse) // Reset mouse { for (auto\u0026amp; state: s_mouse-\u0026gt;ButtonStates) { state.IsPressed = false; state.IsReleased = false; if (resetHeld) state.IsHeld = false; } s_mouse-\u0026gt;WheelH = Mouse::WheelInfo(); s_mouse-\u0026gt;WheelV = Mouse::WheelInfo(); } The Update function # This is a very simple update function that we call every frame that simply calls the above Reset. Here we do not want to reset the \u0026lsquo;held-state\u0026rsquo; of the keys/buttons since we yet do not know if they have been released or not.\nvoid Internal::Update() { Reset(false); } On Window Focus Change # Whenever our window loses focus, we want to reset the keyboard and mouse state. We can do this using the Win32 function called GetFocus which returns a window handle. We can compare this handle with our window handle and check if the window that has focus is our window (else tour window is not being focused). That can be checked for in the input window procedure function after the initialization code and before the the actual input processing takes place. And if we are going to reset here, then we we want to reset the held state of the keys/buttons as well.\nbool Internal::ProcessInputWndProc(HWND hWnd, UINT uMsg, WPARAM wParam, LPARAM lParam) { // Initialization code... // Check for window focus [[unlikely]] if (::GetFocus() != hWnd) { Reset(true); return false; } // Switch statement on uMsg to capture input } Conclusion # One thing I have not included in these posts is the function bodies of the Input getter functions since they are quite straight forward. For keyboard, you convert the input key to an array index and return the state of the key. Similarly, do the same with the mouse getter functions.\nThis input system can now be used as follows:\nInput::Keyboard::KeyState\u0026amp; state = Input::GetKeyState(Input::KeyCode::Escape)) if (state.IsPressed) { // Escape key was pressed this frame do something... } Making an input system from scratch is quite a tedious task, not in complexity, but in lines of code. First you have to declare all the keys and buttons you want to support and create a mapping for each one of them. Then actually process the them. I\u0026rsquo;ll agree that my implementation may not be the best (especially with mapping keycodes to array indices). But I always wanted to understand how input systems are writen and wanted to write one myself from scratch. So here we are.\nProgramming Game Engine C++ Input ","date":null,"permalink":"/posts/mage5_2/","section":"Posts","summary":"Making a Game Engine - Part 5.2 - Input Processing","title":"MAGE - Part 5.2"},{"content":" Finding the keys (and clicks) to success! Check out Nui Engine on Github In the last post I set up the creation of the Win32 window and the message pump. Building up from that I will now go over the base of making an input system we\u0026rsquo;ll look at processing them in the next post.\nTypes of Input Systems # Input systems can be broadly classified into two types:\nPolling based input system Event based input system Polling Based # In a polling based input system first all the Win32 input messages are processed (and cached as key states). These key states can be queried later in the frame during the update loop and can be used by the user.\nPolling based input system Event Based # In an event based input system. A callback is dispatched (usually a function overriden or bound to a delagte by the user) as soon as the Win32 input message is received. This may be configured to execute user code as soon as the input is recieved or may be used via an event queue\nEvent based input system Input Event Queue # One variation of the event based input system is using the event queue. In this version, we receive the Win32 input message, process it and add it to an event queue. This queue can be queried every frame to check for the latest input event and if it is the expected type of event (let\u0026rsquo;s say window resize) then we can process our/user code as needed\nEvent queue based input system Input API Design # For this game enigne, I want the input API to be very similar to the way Unity has it set up (in thier old input system). Which would work best designed as a polling based input system.\nHere is the psuedo-code for the Input API\nif (Input::GetKey(Key::Escape).IsPressed) { // Escape key was pressed this frame } Keyboard # Windows provides a way to query the state keyboard keys using the Virtual Keys and the GetKeyState function. But this only tells us if the key is up or down, it doesn\u0026rsquo;t tell us if the key is being held. Not only that, but we would also have to use Win32 defines in our code which is something I do not want.\nKey Codes # To solve the above issue I made a simple enum class called KeyCode which maps the the virtual key codes\nThis enum is quite massive, so I\u0026rsquo;ve shortened the the code for the post, but the entire enum can be viewed here\nnamespace Nui::Input { enum class KeyCode : U64 { None = 0, LeftArrow = VK_LEFT, RightArrow = VK_RIGHT, UpArrow = VK_UP, DownArrow = VK_DOWN, PageUp = VK_PRIOR, PageDown = VK_NEXT, Home = VK_HOME, End = VK_END, Insert = VK_INSERT . . . NumPad7 = VK_NUMPAD7, NumPad8 = VK_NUMPAD8, NumPad9 = VK_NUMPAD9, NumPadDecimal = VK_DECIMAL, NumPadDivide = VK_DIVIDE, NumPadMultiply = VK_MULTIPLY, NumPadSubtract = VK_SUBTRACT, NumPadAdd = VK_ADD, } } I also have a constexpr function that converts these keycodes to array indices (this will make sense later)\ninline constexpr U64 ConvertKeyCodeToArrayIndex(KeyCode keyCode) { switch (keyCode) { case KeyCode::LeftArrow: return 0; case KeyCode::RightArrow: return 1; case KeyCode::UpArrow: return 2; case KeyCode::DownArrow: return 3; case KeyCode::PageUp: return 4; case KeyCode::PageDown: return 5; case KeyCode::Home: return 6; case KeyCode::End: return 7; . . . case KeyCode::NumPad8: return 106; case KeyCode::NumPad9: return 107; case KeyCode::NumPadDecimal: return 108; case KeyCode::NumPadDivide: return 109; case KeyCode::NumPadMultiply: return 110; case KeyCode::NumPadSubtract: return 111; case KeyCode::NumPadAdd: return 112; case KeyCode::KEYCODE_COUNT: return 113; } // Return out of bounds index return ConvertKeyCodeToArrayIndex(KeyCode::KEYCODE_COUNT) + 1; } Key Modifiers # When pressing any key, the user can also combine modifiers with the key (like control, shift, etc.). For this, I decided to use an enum so it can be merged using bitmasks\nenum Modifier : U64 { MOD_None = 0, MOD_LShift = 1 \u0026lt;\u0026lt; 0, MOD_RShift = 1 \u0026lt;\u0026lt; 1, MOD_LControl = 1 \u0026lt;\u0026lt; 2, MOD_RControl = 1 \u0026lt;\u0026lt; 3, MOD_LAlt = 1 \u0026lt;\u0026lt; 4, MOD_RAlt = 1 \u0026lt;\u0026lt; 5, MOD_LSuper = 1 \u0026lt;\u0026lt; 6, MOD_RSuper = 1 \u0026lt;\u0026lt; 7, }; The Keyboard Structure # I use the following structure to represent the keyboard.\nstruct Keyboard { constexpr Keyboard(); struct KeyState { constexpr KeyState(KeyCode key = KeyCode::None) : Key(key) , Modifier(Modifier::MOD_None) , IsPressed(false) , IsReleased(false) , IsHeld(false) {} KeyCode Key; Modifier Modifier; bool IsPressed; bool IsReleased; bool IsHeld; }; std::array\u0026lt;KeyState, ConvertKeyCodeToArrayIndex(KeyCode::KEYCODE_COUNT)\u0026gt; KeyStates; }; The keyboard is a collection of KeyStates, where every KeyCode is mapped to an index using the ConvertKeyCodeToArrayIndex function. The reason for this is becuase the enum value of KeyCode::KEYCODE_COUNT is not equal to the number of number of actual keys in the KeyCode enum\nI have excluded some keys from the KeyCode enum (like Print Screen, etc.) This causes a mismatch in the indexing of the array if you directly try to map the key code The valie of KeyCode::KEYCODE_COUNT is 108, but when mapped using the function, the size of the Keyboard::KeyStates is 113. Mouse # The Mouse Structure # Here is the structure that I am using to represent the mouse state.\nstruct Mouse { constexpr Mouse(); enum class Button : U32 { None = 0, Left = MK_LBUTTON, // Can be referenced using 0 Right = MK_RBUTTON, // Can be referenced using 1 Middle = MK_MBUTTON, // Can be referenced using 2 MouseX1 = MK_XBUTTON1, // Can be referenced using 3 MouseX2 = MK_XBUTTON2, // Can be referenced using 4 }; static constexpr U32 ConvertMouseButtonToArrayIndex(Mouse::Button btn) { switch (btn) { case Mouse::Button::Left: return 0; case Mouse::Button::Right: return 1; case Mouse::Button::Middle: return 2; case Mouse::Button::MouseX1: return 3; case Mouse::Button::MouseX2: return 4; } // Return out of array bounds index return 5; } struct Point { constexpr Point(I32 x = 0, I32 y = 0) : X(x), Y(y) {} I32 X{ 0 }; I32 Y{ 0 }; }; struct WheelInfo { constexpr WheelInfo() : Delta(0) , Modifier(Modifier::MOD_None) , Position() {} I32 Delta; Modifier Modifier; Point Position; }; struct ButtonState { constexpr ButtonState(Mouse::Button btn = Mouse::Button::None) : Btn(btn) , Modifier(Modifier::MOD_None) , IsHeld(false) , IsPressed(false) , IsReleased(false) {} Button Btn; Modifier Modifier; bool IsHeld; bool IsPressed; bool IsReleased; }; Point Position; Point RawDelta; WheelInfo WheelH; WheelInfo WheelV; std::array\u0026lt;ButtonState, 5\u0026gt; ButtonStates; }; This structure contains an enum for the different mouse buttons (and a constexpr function to convert the enum class to array index), a simple structure to contains the mouse coordinates (or the raw delta), a structure to contains the mouse wheel information and a structure for the mouse button states (similar to Keyboard::KeyState).\nIn the structure we have the following member variables:\nPosition - Contains the pointer position relative to the client RawDelta - Contains the raw delta movement (using raw input) WheelH - The horizontal wheel info WheelV - The vertical wheel info ButtonStates - Similar to the KeyStates from the keyboard structure, contains information about the mouse button states Conclusion # In the next post I will go over processing the Win32 input messages using a custom input window procedure.\nProgramming Game Engine C++ Input ","date":null,"permalink":"/posts/mage5_1/","section":"Posts","summary":"Making a Game Engine - Part 5.1 - Input System Setup","title":"MAGE - Part 5.1"},{"content":" Windows made by Windows! Check out Nui Engine on Github Now that I have a logging and assertion framework up and running. The next thing I want to add is an application window. For this I will be using the Win32 API and no external libraries. Here is what I want my window class to support:\nSimple styling Custom title text Self contained message pump Message routing (with callbacks) Window Styling # I will be supporting 4 different window styles\nWindowed Windowed Fullscreem Borderless Borderless Fullscreem These are the high level styles which are exposed to the end user. They map to an internal style enum class which enables certain styles (like window drop shadows).\n// User facing styles (part of Window class) enum class Style { Windowed, Windowed Fullscreem, Borderless, Borderless Fullscreem } In the .cpp file, hidden from the end user there is an internal style enum:\nenum StyleInternal : DWORD { Windowed = WS_OVERLAPPEDWINDOW | WS_THICKFRAME | WS_CAPTION | WS_SYSMENU | WS_MINIMIZEBOX | WS_MAXIMIZEBOX, WindowedFullscreen = Windowed | WS_MAXIMIZE, AeroBorderless = WS_POPUP | /*WS_THICKFRAME |*/ WS_CAPTION | WS_SYSMENU | WS_MAXIMIZEBOX | WS_MINIMIZEBOX, BasicBorderless = WS_POPUP | /*WS_THICKFRAME |*/ WS_SYSMENU | WS_MAXIMIZEBOX | WS_MINIMIZEBOX, BorderlessFullscreen = WS_MAXIMIZE }; // Borderless styles have no WS_THICKFRAME to disable window resizing (we will handle that manually later) WHen making my window I use a style proxy which strips fullscreen inforamtion from the style. Allowing me to then convert the new style to an internal window style and manually fullscreen the window if needed.\n// Returns a stripped window style and tells if the style contained fullscreen flag Window::Style GetStyleProxy(Window::Style style, bool\u0026amp; outIsFullscreen) { Window::Style styleProxy = style; outIsFullscreen = false; if (styleProxy == Window::Style::WindowedFullscreen) { outIsFullscreen = true; styleProxy = Window::Style::Windowed; } else if (styleProxy == Window::Style::BorderlessFullscreen) { outIsFullscreen = true; styleProxy = Window::Style::Borderless; } return style; } Now that I have our proxy style, I need to convert this to the internal style and this is done using these three functions:\nbool IsCompositionEnabled() { BOOL compositionEnabled = FALSE; bool success = ::DwmIsCompositionEnabled(\u0026amp;compositionEnabled) == S_OK; return compositionEnabled \u0026amp;\u0026amp; success; } StyleInternal GetBorderlessStyle() { return IsCompositionEnabled() ? StyleInternal::AeroBorderless : StyleInternal::BasicBorderless; } StyleInternal ConvertStyle(Window::Style style) { switch (style) { case Window::Style::Windowed: return StyleInternal::Windowed; case Window::Style::WindowedFullscreen: return StyleInternal::WindowedFullscreen; case Window::Style::Borderless: case Window::Style::BorderlessFullscreen: return GetBorderlessStyle(); } return StyleInternal::Windowed; } AeroBorderless are the new types of windows which have Desktop Window Manager Composition toggled (available after Windows 8). Making all Borderless windows AeroBordless by default. Becuase of this some extra work will have to be done to handle window resizing (assuming WS_THICKFRAME is enabled).\nOne could say that I can simply use enums (instead of enum classes) and bit mask flags instead of doing all these unecessary conversions. And you are probably right. But I wrote this code at 4 AM, heavily sleep deprived. And sleepy me thought this was a great idea and I stuck with it. Now its too late to go back and to be honest I am kinda proud of this mess XD.\nThe Window Class # Now that I have the window styling logic out of the way. I can start creating the window itself. Starting with the constructor and the destructor\nstatic const StringW s_windowClassName = L\u0026#34;NuiApp\u0026#34;; Window::Window(Window::Style style, StringViewW title, Window::Size size) : m_style(style) // Window::Style , m_title(title) // Wide string for window title , m_size(size) // Structure containing sizeX and sizeY , m_hWnd(nullptr) // Window handle , m_isFocused(false) // Bool to check if window has focus , m_hInstance(GetModuleHandle(NULL)) // Application instance handle { MakeWindow(); } Window::~Window() { ::DestroyWindow(m_hWnd); ::UnregisterClass(s_windowClassName.c_str(), m_hInstance); } The constructor calls the MakeWindow function which handles window creation which contains the following steps.\nRegistering Window Class # The first step to creating a Win32 window is to register a window class. You can have multiple (actual) windows part of a window class.\nHere I register a window class, where:\nThe window redraw\u0026rsquo;s if the width or height changes (see window class styles) The window uses a static Windows Procedure (explained later) The background is white The cursor is the default cursor The class is then registered using the RegisterClassExW function. This may fail is the class is already registered (which is not a problem), so I simply log that as an error and try to continue. If this was a breaking failure, then the next function where I create a window will fail whose error code will correspond to the window class registeration,\n// Register window class WNDCLASSEXW wcx{}; wcx.cbSize = sizeof(wcx); wcx.style = CS_HREDRAW | CS_VREDRAW; wcx.hInstance = m_hInstance; wcx.lpfnWndProc = WndProc; wcx.lpszClassName = s_windowClassName.c_str(); wcx.hbrBackground = reinterpret_cast\u0026lt;HBRUSH\u0026gt;(COLOR_WINDOW + 1); wcx.hCursor = ::LoadCursorW(nullptr, IDC_ARROW); if (!::RegisterClassExW(\u0026amp;wcx)) { // Log error but try to continue regardless NUI_LOG(Error, Window, \u0026#34;Failed to register window class. \u0026#34;, GetWin32ErrorString(GetLastError())); } Centring The Window # This is a completely optional step. I like all muy windows to be created at the centre of the screen.\nUsing the Win32 API to get the desktop window rect. Then using that RECT to calculate the x and y coordinates to place my window (based on the provided window size).\nRECT desktopRect; ::GetWindowRect(::GetDesktopWindow(), \u0026amp;desktopRect); I32 posX = (desktopRect.right / 2) - (m_size.X / 2); I32 posY = (desktopRect.bottom / 2) - (m_size.Y / 2); Creating The Window # This is the part where the window is actually created. Again using the Win32 API.\nStyleInternal style = ConvertStyle(m_style); m_hWnd = ::CreateWindowExW( 0, // No extended styles s_windowClassName.c_str(), // Registered WNDCLASSEXW name m_title.c_str(), // Title of the window style, // Converted internal style posX, posY, // Position of the window m_size.X, m_size.Y, // Size of the window nullptr, // No parent nullptr, // No menu m_hInstance, // Application instance this // LPARAM ); NUI_ASSERT(m_hWnd, \u0026#34;Failed to create window, handle is nullptr\u0026#34;); Here I pass this as the LPARAM, since I will later be using that to route the window messages to the class memer functions\nApplying Styling # Now that I have the window finally created, it is time to apply the styling I have ranting about from the start.\n// Get style proxy (we will be using this to apply styles) bool fullscreen = false; Style styleProxy = GetStyleProxy(m_style, fullscreen); // We are modifying the style only if the window style is borderless if (HasStyleFlag((DWORD)styleProxy, (DWORD)Style::Borderless)) { StyleInternal style = ConvertStyle(styleProxy); StyleInternal oldStyle = static_cast\u0026lt;StyleInternal\u0026gt;(::GetWindowLongW(m_hWnd, GWL_STYLE)); if (style != oldStyle) { // Set the new style ::SetWindowLongW(m_hWnd, GWL_STYLE, static_cast\u0026lt;LONG\u0026gt;(style)); // Extend frame for resizing (AeroBorderless style) if (IsCompositionEnabled()) { static const MARGINS shadowState[2]{ { 0, 0, 0, 0 }, { 1, 1, 1, 1 } }; ::DwmExtendFrameIntoClientArea(m_hWnd, \u0026amp;shadowState[style != StyleInternal::Windowed]); } // Redraw frame ::SetWindowPos(m_hWnd, nullptr, 0, 0, 0, 0, SWP_FRAMECHANGED | SWP_NOMOVE | SWP_NOSIZE); } } // Show window normal or fullscreen ::ShowWindow(m_hWnd, fullscreen ? SW_MAXIMIZE : SW_SHOWNORMAL); // Update window size RECT rect{}; AdjustWindowRect(\u0026amp;rect, (DWORD)m_style, FALSE); m_size.X = rect.right - rect.left; m_size.Y = rect.bottom - rect.top; Window Message Pump # Windows based applications are event-driven. These events are passed into the windows procedure call after they have been processed by the windows message pump.\nI don\u0026rsquo;t want the engine/external code to deal with the windows message loop. So I made a function called WantsToClose\nbool Window::WantsToClose() const { // Windows message pump MSG msg; while (::PeekMessage(\u0026amp;msg, NULL, 0, 0, PM_REMOVE)) { ::TranslateMessage(\u0026amp;msg); ::DispatchMessageW(\u0026amp;msg); if (msg.message == WM_QUIT) { return true; } } return false; } This can be used like this. Here I check if the window wants to close (this runs the message pump and dispatches all the events which can be handled manually).\nwhile (!window-\u0026gt;WantsToClose()) { now = timer.GetElapsedSeconds(); // Perform update code here dt = now - elapsed; elapsed = now; } This is very similar to the actual code being used in the engine to update the application and the window.\nWindow Procedure # When creating the WNDCLASSEXW I passed in the WndProc as my window procedure function. This is a static member method that like an interface for calling the private MessageRouter function.\nWhen the event NCCREATE (sent prior WM_CREATE when a window is first created) is sent. I extract the this pointer we passed at the LPARAM when creating the window. Then reinterpret the pointer as this window class and set that as the Window Long Pointer. Later, I try to retrieve the long pointer. If succeeded, that means we have our window, on which I call the MessageRouter else call the DefWndProc\nLRESULT WINAPI Window::WndProc(HWND hWnd, UINT uMsg, WPARAM wParam, LPARAM lParam) { switch (uMsg) { case WM_NCCREATE: { LPCREATESTRUCT pCreateStruct = reinterpret_cast\u0026lt;LPCREATESTRUCT\u0026gt;(lParam); Window* pObj = reinterpret_cast\u0026lt;Window*\u0026gt;(pCreateStruct-\u0026gt;lpCreateParams); ::SetWindowLongPtr(hWnd, GWLP_USERDATA, reinterpret_cast\u0026lt;LONG_PTR\u0026gt;(pCreateStruct-\u0026gt;lpCreateParams)); return ::DefWindowProc(hWnd, uMsg, wParam, lParam); } } Window* pObj = reinterpret_cast\u0026lt;Window*\u0026gt;(::GetWindowLongPtr(hWnd, GWLP_USERDATA)); if (pObj) return pObj-\u0026gt;MessageRouter(hWnd, uMsg, wParam, lParam); else return ::DefWindowProc(hWnd, uMsg, wParam, lParam); } Message Router # This the first layer of message indirection where I expose a bit of the low level API to the end user. In my Window class header file have the following defines.\n#define NUI_WNDPROC_ARGS Nui::Window*, UINT, WPARAM, LPARAM #define NUI_WNDPROC_NAMED_ARGS Nui::Window* window, UINT uMsg, WPARAM wParam, LPARAM lParam using WndCallback = std::function\u0026lt;LRESULT(NUI_WNDPROC_ARGS)\u0026gt;; Using that type alias, I have a member map where I can call any message the user wants to interject.\n/** * @brief Window message callbacks * @note The key is the message * @note The value is the callback * @note The callback will be called when the message is received in the MessageRouter */ std::map\u0026lt;U32, WndCallback\u0026gt; m_callbacks; This is how the router function works. It checks if the window message is present in the map and calls the user bound std::function\u0026lt;WndCallback\u0026gt; else calls the actual private member method, the MessageHandler.\nLRESULT Window::MessageRouter(HWND hWnd, UINT uMsg, WPARAM wParam, LPARAM lParam) { if (m_callbacks.contains(uMsg)) { return m_callbacks[uMsg](this, uMsg, wParam, lParam); } else { return MessageHandler(hWnd, uMsg, wParam, lParam); } } Message Handler # Finally this is the final function where a Win32 event will arrive to before either being processed internally, dispatched to another system (such as input messages) or be sent to the the default windows procedure call (because we don\u0026rsquo;t care about it).\nLRESULT Window::MessageHandler(HWND hWnd, UINT uMsg, WPARAM wParam, LPARAM lParam) { switch (uMsg) { case WM_NCCALCSIZE: { if (wParam == TRUE \u0026amp;\u0026amp; HasStyleFlag((DWORD)m_style, (DWORD)Style::Borderless)) { auto\u0026amp; params = *reinterpret_cast\u0026lt;NCCALCSIZE_PARAMS*\u0026gt;(lParam); AdjustMaximizedClientRect(params.rgrc[0]); return 0; } break; } case WM_NCHITTEST: { // When we have no border or title bar, we need to perform our // own hit testing to allow resizing and moving. if (HasStyleFlag((DWORD)m_style, (DWORD)Style::Borderless)) { return HitTest(POINT{ GET_X_LPARAM(lParam), GET_Y_LPARAM(lParam) }); } break; } case WM_DESTROY: { ::PostQuitMessage(0); return 0; } case WM_CLOSE: { DestroyWindow(hWnd); return 0; } case WM_SETFOCUS: { m_isFocused = true; return 0; } case WM_KILLFOCUS: { m_isFocused = false; return 0; } return ::DefWindowProc(hWnd, uMsg, wParam, lParam); } In the above function I handle the following messages\nWM_NCCALCSIZE Sent when the size and position of a window\u0026rsquo;s client area must be calculated. Allows me to control the size and area of the the client WM_NCHITTEST Sent in order to determine what part of the window corresponds to a particular screen coordinate Allows me to manually control check for hit test when resizing a bordeless window (when WS_THICKFRAME is enabled) WM_DESTROY Sent when the window is destroyed I use this to trigger the close of the application WM_CLOSE Sent when the close button or Alt+F3 is pressed I use this to destroy the window, causing WM_DESTROY to be sent WM_SETFOCUS/WM_KILLFOCUS Sent when the window gains or loses input focus Use this to check if the window is currently focused, will be usefull when designing the input system Manual Hit Testing # Here is the function that I call whenever the WM_NCHITTEST is sent\nLRESULT Window::HitTest(POINT cursor) { // Identify borders and corners to allow resizing the window. // Note: On Windows 10, windows behave differently and // allow resizing outside the visible window frame. // This implementation does not replicate that behavior. const POINT border { ::GetSystemMetrics(SM_CXFRAME) + ::GetSystemMetrics(SM_CXPADDEDBORDER), ::GetSystemMetrics(SM_CYFRAME) + ::GetSystemMetrics(SM_CXPADDEDBORDER) }; RECT window; if (!::GetWindowRect(m_hWnd, \u0026amp;window)) { return HTNOWHERE; } enum region_mask { client = 0b0000, left = 0b0001, right = 0b0010, top = 0b0100, bottom = 0b1000, }; const auto result = left * (cursor.x \u0026lt; (window.left + border.x)) | right * (cursor.x \u0026gt;= (window.right - border.x)) | top * (cursor.y \u0026lt; (window.top + border.y)) | bottom * (cursor.y \u0026gt;= (window.bottom - border.y)); // Return where the mouse hit test switch (result) { case left : return HTLEFT; case right : return HTRIGHT; case top : return HTTOP; case bottom : return HTBOTTOM; case top | left : return HTTOPLEFT; case top | right : return HTTOPRIGHT; case bottom | left : return HTBOTTOMLEFT; case bottom | right: return HTBOTTOMRIGHT; case client : return HTCLIENT; default : return HTNOWHERE; } } Conclusion # And finally with all that work, we finally have a window. Although one can simply get away with registering a window class and setting the window style to WS_OVERLAPPEDWINDOW along with performing proper message routing (with the message pump). I decided to go ahead and implement a alightly fancier windowing system. Which may or may not be too complex / over the top for basic needs.\nBut I am glad you stuck around till the end of the article. This was a long one. In the next one we will look at using the message routing system to create an Input System. Which will allow read keyboard and mouse inputs. See you in the next one! üëã\nProgramming Game Engine C++ ","date":null,"permalink":"/posts/mage4/","section":"Posts","summary":"Making a Game Engine - Part 4 - Windowing","title":"MAGE - Part 4"},{"content":" Throw it - Catch it - Log it Check out Nui Engine on Github With the project files now generated, we can start writing engine code. Every game engine needs a logging and error catching framework. Here is how I designed one for Nui Engine (with pseudocode).\nLogging # Log Levels # Every log message will have a verbosity level. Which is defined using an enumeration.\nenum class LogLevel { Debug, // For low level engine information Info, // For general information Warn, // For warnings Error, // For errors Fatal, // Similar to \u0026#39;Error\u0026#39;, also gives a stacktrace Exception // Similar to \u0026#39;Error\u0026#39;, also gives a stacktrace and crashes the program } LogEntry # Each log message will be wrapped in a LogEntry structure which contains additional information regarding the log message.\nstruct LogEntry { LogLevel Level; // Log level of the message String Category; // Log category of the message String Message; // The log message to display TimePoint Time; // Time point of log message Stacktrace Stacktrace; // The stacktrace to the location of log message } Since I am using C++23 for this project I have access to std::stacktrace which is what I am using to generate my stacktrace. There is also a header only stacktrace library called backward-cpp which contains a bunch of additional features. Although I did not use it here since I want the engine to have minimal external dependencies.\nLog File # Since I plan to use this engine with Visual Studio, I am going to use the VS Output Window as my log message output window. I will also be using a log file in case someone is not using Visual Studio (presently external debggers already hook into the OutputDebugString function using which the log message can also be viewed in the debuggers output window).\nI also created an internal structure called a LogFile which can be opened and closed using helper functions. To which the same formatted log message can be appended.\nThe log file resides in the \u0026lt;WorkingDir\u0026gt;/Saved/NuiEngine.log\nPrinting the Log # To print the log I have a function called Log which takes a LogEntry and formats it and prints it out.\nvoid Nui::Log(const LogEntry\u0026amp; entry) { // Make formatted log message from entry // Append time, category and verbosity with the message String formattedMsg = ... ; // Redirects string to output window and file (if opened) LogOut(formattedMsg); if (entry.Level == LogLevel::Fatal) { // Format and print the stacktrace to the output window/file PrintStacktrace(entry.Stacktrace); } } Although I do not want the user to directly use this function or create a LogEntry manually everytime they want to log something. So I made a wrapper macro.\n// The LogEntry constructor default initializes the stacktrace from this point #define NUI_LOG(Level, Category, Message) Nui::Log::Log(Nui::Log::LogEntry(Nui::Log::LogLevel::Level, #Category, Message)) Here is how the log message looks like in debug build (I have an extension called VSColorOutput enabled which highlights my output messages).\nLog test output in VS output window Assertions # Instead of using the default assert provided by C++. I wanted to make my own assert that makes use of LogLevel::Exception.\nI made a the following Assert function\nvoid Assert(bool condition, StringView conditionString, StringView message, StringView file, I32 line, Stacktrace trace) { if (!condition) { // Build a log message using the condition string and message String logMsg = ... ; // Create a log entry with level set to exception Log(LogEntry(LogLevel::Exception, ...)); // Manually print the trace PrintStackTrace(trace); // Crash the program throw std::runtime_error(\u0026#34;Assertion failed!\u0026#34;); } } Assertions in Nui are meant to be used using this macro\n#if NUI_DEBUG #define NUI_ASSERT(Condition, Message) Nui::Log::Assert(Condition, #Condition, Message, __FILE__, __LINE__) #else #define NUI_ASSERT(Condition, Message) #endif Here you can see the output window with the formatted message when an assertion fails, along with the stacktrace and file/line.\nOutput window when an assertion fails Conclusion # I would like to add the ability to set the log verbosity level. But at the time of development, I\u0026rsquo;d rather have all the log message printed so this is something we can come back to in the future. I\u0026rsquo;d also want to make the logging system multithreaded.\nOnce I have some Win32 specific functionality added in, I\u0026rsquo;d also like to show a message box when the program fails an assert in release mode such that the end user doesn\u0026rsquo;t have to go through the created log file to find out why the program crashed.\nAs usual the complete source code for this project is available on my GitHub repository (see top of page). If you want to see the documented implementation details.\nProgramming Game Engine C++ ","date":null,"permalink":"/posts/mage3/","section":"Posts","summary":"Making a Game Engine - Part 3 - Logging and Assertions","title":"MAGE - Part 3"},{"content":" First there was project architecture then there was directory structure Check out Nui Engine on Github The Process # Since this is an editor-less game engine. We need to plan how the user\u0026rsquo;s game (project) is integrated with the engine/project solution. Here is the proposed usage pipeline:\nClone/Fork the Github repository Run a script to generate project build scripts Generate project files Open Visual Studio solution with engine and user game code projects linked! The Build System # Since I am only developing this project for the Windows OS, I plan to use Visual Studio as my IDE and therefore MSVC as my C++ compiler. But to generate the solution and add the user project files I will be using Premake as my solution generator/build system.\nProject Folder Structure # When the user clones the repository, they should see the following folder structure\nNuiEngine (Root)/ ‚îú‚îÄ Docs/ ‚îÇ ‚îú‚îÄ Doxygen generated docs ‚îú‚îÄ Build/ ‚îÇ ‚îú‚îÄ Intermediate/ ‚îÇ ‚îú‚îÄ \u0026lt;BUILD_CONFIG\u0026gt;/ ‚îÇ ‚îÇ ‚îú‚îÄ NuiCore/ ‚îÇ ‚îÇ ‚îú‚îÄ NuiTest/ ‚îÇ ‚îÇ ‚îú‚îÄ NuiConsole/ ‚îÇ ‚îÇ ‚îú‚îÄ NuiGraphics/ ‚îÇ ‚îÇ ‚îú‚îÄ NuiAudio/ ‚îÇ ‚îÇ ‚îú‚îÄ \u0026lt;USER_PROJECT_NAME\u0026gt;/ ‚îÇ ‚îÇ ‚îÇ ‚îú‚îÄ Saved/ ‚îÇ ‚îÇ ‚îÇ ‚îÇ ‚îú‚îÄ NuiEngine.log ‚îÇ ‚îÇ ‚îÇ ‚îú‚îÄ \u0026lt;USER_PROJECT_NAME\u0026gt;.exe ‚îú‚îÄ Scripts/ ‚îÇ ‚îú‚îÄ Templates/ ‚îÇ ‚îÇ ‚îú‚îÄ PremakeProjectTemplate.lua ‚îÇ ‚îÇ ‚îú‚îÄ PremakeSolutionTemplate.lua ‚îÇ ‚îú‚îÄ premake5.exe ‚îÇ ‚îú‚îÄ CreateProject.py ‚îú‚îÄ Engine/ ‚îÇ ‚îú‚îÄ Core/ ‚îÇ ‚îÇ ‚îú‚îÄ BuildCore.lua ‚îÇ ‚îú‚îÄ Graphics/ ‚îÇ ‚îÇ ‚îú‚îÄ BuildGraphics.lua ‚îÇ ‚îú‚îÄ Audio/ ‚îÇ ‚îÇ ‚îú‚îÄ BuildAudio.lua ‚îÇ ‚îú‚îÄ Console/ ‚îÇ ‚îÇ ‚îú‚îÄ BuildConsole.lua ‚îÇ ‚îú‚îÄ Test/ ‚îÇ ‚îÇ ‚îú‚îÄ BuildTest.lua ‚îú‚îÄ \u0026lt;USER_PROJECT_NAME\u0026gt;/ ‚îÇ ‚îú‚îÄ \u0026lt;USER_PROJECT_NAME\u0026gt;/ ‚îÇ ‚îÇ ‚îú‚îÄ Game code... ‚îÇ ‚îú‚îÄ Main.cpp ‚îÇ ‚îú‚îÄ Build\u0026lt;USER_PROJECT_NAME\u0026gt;.lua ‚îú‚îÄ GenerateProjectFiles.bat Initially there will be no Build and User Project folder. That will be generated using the Scripts/CreateProject.py script. All engine modules will be the in the Engine folder with their respective Premake Lua build files. These will be defined manually and will not change during project generation. I also include the premake5.exe with the repository.\nIn the Scripts folder there are also premake template files for the solution and user project that the python script will use when creating a project.\nCreating a New Project # To create a new project the user will have to run Scripts/CreateProject.py with the project name as the command line argument. The goal is to run this script only once when the project has to be created for the first time.\nUsing Python # I decided to use python since it\u0026rsquo;s super easy to easy to write and can be executed on the fly. This is what the Python script does:\nTakes the user project name as an command line argument Usage (cmd): CreateProject.py -projectname=\u0026lt;USER_PROJECT_NAME\u0026gt; Creates project directory in the root folder Creates the Build\u0026lt;USER_PROJECT_NAME\u0026gt;.lua using the PremakeProjectTemplate.lua file in the project directory Creates a sub folder in the project directory with the same name as the project. This is where the user code will be written. Calls premake5.exe to generate the Visual Studio solution and project files Generating Project Files # There is also a batch script in the root folder called GenerateProjectFiles.bat. Which invokes premake5.exe and can be used to update the project and solution when new files are added.\nWith this system I can also create GitHub actions to run the tests automatically.\nWith all that done, we now have a project generated with the right links. You can check the implementation details on the GitHub repository.\nProgramming Game Engine ","date":null,"permalink":"/posts/mage2/","section":"Posts","summary":"Making a Game Engine - Part 2 - Generating Project Files And Project Structure","title":"MAGE - Part 2"},{"content":" A new game engine! Check out Nui Engine on Github Introducing Nui Engine # This game engine project is called Nui Engine and will be built using C++. Unlike most game engines, this will be an editor-less game engine. I want the user to control everything via C++ code. There will be a command console using which the user can communicate with the game engine (such as executing commands like game cheats and getting engine information).\nEngine Architecture # The engine will be split into the following modules:\nNuiCore Built as a static library Contains core engine functionality such as windowing, input and main loop management Also contains the main entry point Links with the NuiGraphics and NuiAudio libraries NuiGraphics Built as a static library Contains the DirectX 11 2D renderer NuiAudio Built as a static library Contains all audio related functionality GameCode Built as an executable Contains all user written game code which auto-registers with the engine and is dynamically called Links with NuiCore NuiTest Uses MSTest to test engine functionality (thereforce built as a DLL) Can be extended by the user to test gameplay code Links with all modules ProjectGenerator A collection of templates and python scripts used to generate solution and project files See below a diagram of the planned engine architecture.\nNui Engine Architecture With the engine architecture planned, I will next work on generating project files. So that we can then start working on the engine itself.\nThe name \u0026lsquo;Nui\u0026rsquo; was proposed by my univerity lecturer (who I asked for name suggestions) since this engine has no editor (No UI). Thanks Tom!\nProgramming Game Engine Software Architecture ","date":null,"permalink":"/posts/mage1/","section":"Posts","summary":"Making a Game Engine - Part 1 - Engine architecture","title":"MAGE - Part 1 "},{"content":" Check out Nui Engine on Github Introduction # Heylo and welcome to the start of a new project!\nAs you may have seen from my projects page, I\u0026rsquo;ve been tinkering quite a bit into the world of game development, mostly on the low level side of things. Recently I\u0026rsquo;ve got the itch to make another game engine from scratch and I figured, why not bring you along for the ride?\nSo, here we are! I\u0026rsquo;ve decided to make use of this blog space on my website to document my journey of yet another game engine.\nWhy Document This Journey? # You see, I have a habit of starting projects and abandoning them halfway through. My last documented project was the game engine I made in my final year of university. Since then I\u0026rsquo;ve attempted to make at least 4 other game engines which have never seen the light of day and all are sitting in private repos. They all have an explosive start, but I end up abandoning them a couple months into the project.\nBut not this time! I will use this blog basically as an excuse to hold myself accountable with regular updates and posts, I\u0026rsquo;m gonna stay on track and see this thing through to the end (hopefully ü§û).\nWhat to expect # Well, I\u0026rsquo;ll be sharing everything, from brainstorming sessions, to engine architecture, design decisions and fun C++ tidbits. Some posts might be code-heavy, other might be small bite-sized articles. Let\u0026rsquo;s see how things go :D\nAnd Finally # Hopefully, the future articles are helpful and enjoyable to read. Keeping in mind it\u0026rsquo;s also my first time writing blogs of any kind, so there is definitly some room for improvement.\nI hope you\u0026rsquo;ll stick around for the development of this new project üòÑ.\nCatch ya around!\nProgramming Game Engine ","date":null,"permalink":"/posts/mage0/","section":"Posts","summary":"Humble Beginnings - Documenting My Journey Making a Game Engine","title":"Making a Game Engine - Part 0"},{"content":" Procrastinating my next project with many unfinished ones in front of me! ","date":null,"permalink":"/posts/","section":"Posts","summary":"Procrastinating my next project with many unfinished ones in front of me!","title":"Posts"},{"content":"Here is a list of all the projects I have worked on over the years. Click on the project to read more about it!\n","date":null,"permalink":"/projects/","section":"Projects","summary":"Here is a list of all the projects I have worked on over the years.","title":"Projects"},{"content":"For my final year project for my university I made a simple 2D game engine. For this project I research what goes into making a game engine and try to implement my learnings. Written in C++ 20, DirectX 11 and HLSL and based on and ECS and event-driven architecture. The editor is also written in C++ using ImGui. It also supports entity scripting using Lua.\nCheck out the project repository on Github. Watch the demo video here\nArchitecture # The project consists of two sub projects - The Engine and the The Editor. The engine compiles to a static library (.lib) and the editor compiles to an executable (.exe)\nProximity Engine Architecture Proximity\u0026rsquo;s architecture is inspired from Hazel and the initialization chain is inspired from Unreal Engine.\nProximity Engine Initialization Chain Engine Features # Watch the demo video Here are the key features of the engine, some of which are explained in detail after:\nWindow and Input Handling Audio Engine using XAudio2 Custom math library Event driven architecture using Actions Graphics engine and rendering using DirectX 11 Filesystem and directory management Engine logging system Engine utilities Asset libraries (Audio, Shaders, Material, Textures, Scripts) Memory managers (Stack and Pool Allocators) Detailed HLSL shader reflection Scripting using Lua Physics using Box2D Game/Project Serialization using Yaml-Cpp Multiple scenes and project management Entity Component System using ENTT Proximity Editor HLSL Shader Reflection # One of the most impressive features of the game engine is the shader reflection system. The user can write any HLSL code (vertex or pixel shader). The shader is then compiled and reflected within in the engine. The user can then create a Material which is a pair of vertex and pixel shaders. This material is then reflected in the editor; constant buffers and input resource slots can be manually edited from within the editor\nShader reflection system Actions # I recreated the System.Action\u0026lt;\u0026gt; class from C# in C++ 20. And this is what drives the communicatation between the engine and the editor and between the different editor panels.\nThe user can create custom action events (which may or may not take arguments) and bind their own functions/lamdas to these actions. Whenever an action is called, all the bound functions to this action are also called.\nLua Scripting # The engine supports entity scripting using Lua and the Sol2 library. The engine creates a custom runtime environment for each script in the game. The user can call functions to and from C++ and Lua and all of this is made easy using the Sol2 library. The scripts are written in the built in script editor which also has support for syntax hightlighting for engine specific functions.\nConclusion # During this project, I learnt so many new things about C++, HLSL, DirectX 11 as a whole. I believe I have built this project to be the showcase of my skills a C++ and engine programmer and is definitely will be the highlight project of my portfolio along with being the most complex project I\u0026rsquo;ve worked on till date. With some changes to the project and scope, I will definitely make Proximity 2.0, which will be faster with even more supported features.\nI did not talk about the intricate details about all the features of this project or this would turn into a 30 minute long article. But you can always check out the project repository on github or contact me :)\nC++ DirectX 11 HLSL Lua ImGui Programming Game Engine Backend Development ","date":null,"permalink":"/projects/proximityengine/","section":"Projects","summary":"2D C++ and DirectX 11 game engine I made for my final year project","title":"Proximity Game Engine"},{"content":"I have always wanted to try making a complex Ai system before (better than a FSM). And in that list, there were two main ones. GOAP and Neural Networks, specifically NEAT and Genetic Algorithms. Although my original plan for this module was to make a platformer (similar) to Super Mario Bros. and train a NEAT algorithm on it. Due to the scope and time constraints, I decide to drop that idea and move on to make GOAP in a survival game.\nUnderstanding GOAP # GOAP stands for Goal Oriented Action Planning.\nThe way GOAP works is takes in a starting world state and a goal (target world state). These two, along with a list of all possible actions are sent into the planner. The planner generates a list of actions to take by performing A* search in the actions list based on the preconditions and effect of the provided actions.\nHow I Deal With GOAP # In my implementation of GOAP in Unity. I do not have any classes that define a goal. Everything is defined as a world state.\nC# files for implementing GOAP in Unity Which means the planner takes in the current world state and the target world state (and the actions list).\nThe actions are built by setting preconditions and effects on the world state and by providing a delegate that is executed when an action is executed.\nHere is a snippet of code from my implementation\n// Create a new action called move to drinking point and give it an execution cost GOAP.Action moveToDrinkingPoint = new(\u0026#34;Move to drinking point\u0026#34;, MOVEMENT_COST); // Precondition world state for this action to be executed is that \u0026#39;Player Is Thristy = true\u0026#39; moveToDrinkingPoint.SetPrecondition((int)WorldKey.PlayerIsThristy, true); // The effect of the action on the world state on execution is \u0026#39;Play Is Going To Drink = true\u0026#39; moveToDrinkingPoint.SetEffect((int)WorldKey.PlayerIsGoingToDrink, true); // Set up the function that is called when the action is executed and the function that checks if this action can execute on the current world state (runtime check) moveToDrinkingPoint.SetupExecution( () =\u0026gt; // Execution { m_player.MoveAStar(m_drinkingPoint.transform.position); }, () =\u0026gt; // Checker { // Returns true id the player has reached the drinking point return m_player.HasReachedDestination; }) Like that multiple actions can be set up. The planner then chains them up based on matching preconditions and effects (using A*).\nAction/Goal Chart # Here is a chart showing all the actions and their desired preconditions and effects\nAction/Goal relationship chart Along with GOAP, this project has a comprehensive 2D tilemap terrain analysis system (visualization shown in the cover image)\nCheck out the demo and walkthrough on YouTube Check out the project repository on Github C# Ai Unity Game Development ","date":null,"permalink":"/projects/goapai/","section":"Projects","summary":"GOAP in Unity","title":"Goal Oriented Action Planning in Unity"},{"content":"Incognito is a rogue-lite procedural stealth game made in Unreal Engine 5 using C++ and Blueprints. The player playes through a series of rooms (level). After finishing a level, they are brought back to the hub where they can choose weapon and stealth upgrades for their next run. Due to procedural level generation, each level/run is different.\nGame Trailer My Role # This game was made during a university studio simulation module where second and third year students from various fields in game development (design, art, sound, programming) get together to make a game in 6 weeks. The seniors act like deparment leads and the juniors work along with and learn under their guidance.\nThe goal of this module was to make a game in 6 weeks. This game did not have be a complete game, but a vertical slice of a possible game with as many features added that time would allow.\nI was the tech lead and project manager for a team of 22 students. I made the core gameplay systems and the procedural algorithm that generates the map/levels of the game.\nIncogniito Promotional Art My Work # As the Project Manager # As the project manager, my role was to make sure all the other seniors (deparment leads) were on track and make sure the juniors were completing the tasks assigned to them. This was done using Jira to make sure all work was done in time. I also was heavily invovled in deciding the scope of the project.\nAs the Tech Lead # As the tech lead, my role was to design and implement the core gameplay systems and also build a framework easy enough so that the jkuniors can take over along with being designer friendly. Along with feature implementation, I also had to perform version control on the project and handle various department branches and merge conflicts. Most of the version control management was done using command line Git (since handling merge conflicts for UE5 blueprints is a pain).\nManaging the project via Git Procedural Level Generation # Incognito is a stealth game where the levels the user plays (internally referred to as rooms) are generated based on a stripped down version of the Wave Function Collapse (WFC) Algorithm. All the code for the generation was written in C++ and was highly optimized (100 rooms generated in about 2 seconds).\nGenerating 100 rooms using WFC (for fun) The code was written in such a way that no designer ever had to touch any C++. All required functionality was exposed to the Unreal Editor.\nI provided the designers with a list of templates for each type of room they had to make. All these rooms were then input into a custom data table (written in C++).\nRoom layout template provided to designers The rooms were divided into three types based on the number of openings they had:\nC-Type Rooms: Rooms with 1 opening L-Type Rooms: Rooms with 2 openings adjacent to each other I-Type Rooms: Rooms with 2 openings opposite to each other Each type of room had 4 variants (for every type of rotation). All that was needed to be done was to fill in th neighbor and connections info in the data table. Provide the data table to the generator and generate the level when needed.\nDesigner friendly room layout infographic Additional Work # Enemy Ai # I also worked on other features such as developing the core (3 layer) communication system for all the Ai that was spawned in each room:\nAi-Ai communication: One Ai enemy communicating with other nearby Ai enemies Ai-Room communication: Ai enemies communicating with the room to ambush the player in lockdown mode Room-Level communication: Each room communicated with a game manager gathering telemetry data such as number of enemies killed and how stealthily the player completed a room. This was also used to check if a certain level was finished I also worked on building a base for all Ai enemies, which was later extended by other senior programmers.\nLockdown Mode # One of the most fun features of this game is the Lockdown Mode I helped build with the other senior programmer on the team. It was like a panic mode in the game. If during a player\u0026rsquo;s \u0026rsquo;escape\u0026rsquo; from a room was caught by the Ai. All the enemies in the room would be made aware of the players location and they would collectively attack the player. During this phase, the player no longer has to complete the level stealthily. They have to kill as many enemies, find the key to the exit and leave the room. This intermediate game mode totally changed the way the game is played.\nIf the player managed to find the key and exit the room without killing all the enemies in the room. The next entered room would begin on lockdown mode (keeping in mind player has limited ammo and health)\nDynamic Enemy Wander # One of features I worked on a dynamic enemy wander system. Since all the rooms were pre-built by designers and the generator only placed the room in the game world. If the enemy roaming spots were already pre-defined, the player could simply remember them and easily defeat a room.\nTo counter this, I made use of th Unreal\u0026rsquo;s Environmnet Query System (EQS) to get a random list of wander points based on multiple criterias. These wander points would be randomized and shuffled for each enemy in each room.\nCheck out the project repository on Github Game Unreal Engine C++ Ai Blueprints Team Work Programming Management Design Game Dev ","date":null,"permalink":"/projects/incognito/","section":"Projects","summary":"Procedural rogue-lite game made in UE5","title":"Incognito"},{"content":"This project demonstrates my skills in advanced rendering techniques. Written using C++ and DirectX 11 using a custom framework.\nHere are the features of the project\nOBJ Mesh Loading User input (mouse and keyboard) Forward Rendering Deferred Rendering Point Light Support Normal Mapping Parallax Mapping with Self Shadowing using Ray Tracing (forward rendering only) Render to Texture Render to Full Screen Quad Screen Space Effects (vignette, grayscale, etc.) G-Buffer Visualization Check out the project repository on Github Tech Demo C++ DirectX 11 HLSL Graphics Rendering Engine Programming Backend Development ","date":null,"permalink":"/projects/advancedgraphics/","section":"Projects","summary":"Project demonstrating advanced graphics techniques in DirectX 11","title":"Advanced Graphics"},{"content":"A bare bones attempt at a 2D/3D game engine. Used this project to prepare for making Proximity 2D in an attempt to find my ideal engine architecture. Written in C++ using the DirectX 11. Inspired from the Hazel Game Engine from The Cherno.\nCheck out the project repository on Github C++ DirectX 11 HLSL Programming Game Engine Backend Development ","date":null,"permalink":"/projects/primeengine/","section":"Projects","summary":"Prototype game engine made as practice","title":"Prime Engine"},{"content":"A short top down shooter game made in the Unity Game Engine.\nThe player has to clear a procedurally generated dungeon where the current gun weilded by the user is randomly changed.\nThe game\u0026rsquo;s difficult increases the longer the player is alive with various enemy types and the number of enemies.\nCheck out the project repository on Github Game C# Unity Programming ","date":null,"permalink":"/projects/topdownshooter/","section":"Projects","summary":"Top down shooter game made in Unity","title":"Unity Top Down Shooter"},{"content":"Made for my second university year, this project was my first introduction to the DirectX 11 API, making it my first ever rendering engine.\nFeatures:\nLighting Directional Lights Point Lights Mesh Loading Vector3 Class GameObject Class Texture2D Class Camera Static Camera Orbit Camera First Person Camera Sky sphere Terrain Rendering Editable terrain colors using ImGui and shaders Circular Wave Generator Using Vertex Shaders Editable using ImGui Check out the project repository on Github C++ DirectX 11 HLSL Programming Rendering Engine Backend Development ","date":null,"permalink":"/projects/renderingengine/","section":"Projects","summary":"Simple rendering engine (C++ and DX11)","title":"DX11 Rendering Framework"},{"content":"This was my first project where I made a game without using an engine in C++ using SDL2\nThis platformer framework has the following features:\nSprite loading / texture class Import collision map from CSV file Simple 2D physics engine Text class Audio manager Page scrolling system Multi scene support UI buttons 2 different Ai enemies Collectible coins 2 player control support Player health/damage system Player attack bullets Project menu screen Check out the project repository on Github C++ SDL 2 Programming Game Engine Game Development ","date":null,"permalink":"/projects/sdlplatformer/","section":"Projects","summary":"Mario remake using SDL","title":"SDL 2 Mario Remake"},{"content":"Dimension Drift is a short puzzle game made for the GMTK Game Jam 2021 in 48 hours.\nThe theme of the game jam was Joined Together. In this game you solve puzzles while switching between dimensions each having its own restrictions in movement. You can move forward and backward in 2D, but change your depth position in 3D.\nPLAY THE GAME! Images # Here are some screenshots from the game\nDimension Drift Gameplay Image 1 Dimension Drift Gameplay Image 2 Dimension Drift Gameplay Image 3 Project Tags # Game Jam Unity C# Programming Game Dev GMTK Game Jam 2021 ","date":null,"permalink":"/projects/dimensiondrift/","section":"Projects","summary":"Puzzle game made for GMTK Game Jam 2021","title":"Dimension Drift [GMTK Game Jam 2021]"},{"content":"This game was made for the Ai and Games Jame 2021. The main goal of the project was to improve my AI development and design skills.\nThe theme of this game jam was Breaking The Rules. So in this game the robots broke the Three Laws of Robotics made by Issac Assimov (hence the name).\nIn this game you play as a robot, where you break Asimov\u0026rsquo;s 3 rules/laws of robotics by fighting against intelligent AI.\nHow the AI Works # This was the first time I made my own Finite State Machine (FSM) framework in Unity.\nBy default the enemy robots will wander around If the player comes in the field of vision, they will switch to chase state and follow the player Once close enough the enemy will start shooting the player If the enemy itself takes enough damage, it will try to take cover by finding the nearest safe cover spot If it stays safe for some time without the player noticing, backup will be called (3 enemies are spawned) The main goal of the player should be to prevent the enemy robot from going to safety and calling for backup whilst trying to complete the game in the quickest time possible Images # Here are some screenshots from the game:\nAgainst Asimov Gameplay Image 1 Against Asimov Gameplay Image 2 Against Asimov Gameplay Image 3 Download and play the game on Itch.io C# Ai Unity Game Jam AI and Games Jam 2021 Game Development ","date":null,"permalink":"/projects/asimov/","section":"Projects","summary":"Submission for AI and Games Jam 2021","title":"Against Asimov [Ai and Games Jam 2021]"},{"content":"Maze Meltdown is a horror game I made when I took part (solo) in the Global Game Jam held in my university.\nHaving never worked with audio in Unity before. I used this game jam as an oppurtunity to learn about audio programming in Unity,\nSee playthrough video on YouTube Play the game on Itch.io Check out the project repository on Github Game C# Unity Programming Global Game Jam 2021 ","date":null,"permalink":"/projects/mazemeltdown/","section":"Projects","summary":"Horror game made for Global Game Jam 2021","title":"Maze Meltdown [Global Game Jam 2021]"},{"content":"This game was made for the Discord Jam #5. The theme for this game jam was Mutation.\nIn this game, the ball is an experiment which has different DNA structures which give it different powers (which are both positive and negative in effect), only for a set amount of time.\nThese changes in powers is denoted by the change in color of the ball.\nImages # Here are some screenshots from the game:\nMutant Mashup Gameplay Image 1 Mutant Mashup Gameplay Image 2 Download and play the game on Itch.io C# Unity Game Jam Discord Jam #5 Game Development ","date":null,"permalink":"/projects/mutant/","section":"Projects","summary":"Submission for Discord Jam #5","title":"Mutant Mashup [Discord Jam #5]"},{"content":"A short puzzle platformer made for the Brackeys Game Jam 2020.2\nYou play as a bot, whose goal is to put all the energy cubes into their energy bars, so as to progress to the next level. But here\u0026rsquo;s the catch, you cannot reach some parts of the level. For those areas you have to reverse the time for specific objects, to make them work like moving platforms.\nPlay online on Itch.io C# Unity Game Jam Brackeys Game Jam 2020.2 Game Development ","date":null,"permalink":"/projects/timetraversal/","section":"Projects","summary":"Submission for Brackeys Game Jam 2020.2","title":"Time Traversal [Brackeys Game Jam 2020.2]"},{"content":"This game was made for the GMTK Game Jam 2020, where the theme was Out of Control. This was my first ever 3D game made in Unity.\nIn this game, time is out of control. The game speeds up and slows down as per the supposed AI\u0026rsquo;s wish.\nImages # Here are some screenshots from the game:\nTurbulent Time Gameplay Image 1 Turbulent Time Gameplay Image 2 Download the game on Itch.io C# Unity Game Jam Discord Jam #5 Game Development ","date":null,"permalink":"/projects/turbulenttime/","section":"Projects","summary":"Submission for GMTK Game Jam 2020","title":"Turbulent Time [GMTK Game Jam 2020]"},{"content":"This game was made the for the United Game Jam 2020, who\u0026rsquo;s theme was Two. This was my second ever game made in Unity.\nIn this game, the player controls two characters in different dimensions. The goal of the game is make the two characters reach the end of the level before the red barrier kills them.\nIn this project I focused on making smooth camera that tracks and encompasses both the players.\nImages # Here is a screenshot from the game:\nTurbulent Time Gameplay Image 2 Download the game on Itch.io C# Unity Game Jam United Game Jam 2020 Game Development ","date":null,"permalink":"/projects/binaryrift/","section":"Projects","summary":"Submission for the United Game Jam 2020","title":"Binary Rift [United Game Jam 2020]"},{"content":"Introduction # Hey there! I am Arnav, and you are currently having a one-sided-textual-probably-monotonous-talk with me through this page :)\nA picture of me touching grass XD Game Development and Backend Focus # I recently completed my BSc (Hons) Computer Games Design and Programming degree from Staffordshire University (2020-2023). Game development has always been my jam, and I\u0026rsquo;ve had a blast working with Unity and Unreal game engines.\nWhile game development is my passion, I\u0026rsquo;ve discovered a special love for backend development. I\u0026rsquo;m fascinated by the inner workings of game engines, rendering engines, and the tools that power the magic. As part of my final year project, I even built a game engine from scratch, which you can explore in my portfolio.\nI\u0026rsquo;m well-versed in the art of coding and consider C++ and C# to be my trusty sidekicks. Additionally, I\u0026rsquo;ve dabbled in DirectX 11 and HLSL, which have allowed me to create some complex projects over the years. Along with being well versed in version control tools like Git/Github and project management tools like Jira.\nI thrive on analytical and logical thinking, transforming problem-solving into an exhilarating adventure. With a solid foundation in mathematics, including vector math and the mathematical principles behind graphics programming, I bring a unique perspective to crafting immersive and engaging games that prioritize functionality over aesthetics.\nPassion for Game Jams # In addition to my passion for game development, I absolutely love taking part in game jams. Although I am not much of a gamer myself.\nThese intense and creative events allow me to challenge myself and explore new ideas within tight deadlines. For every game jam that I take part in, I try to learn something new. All my game jam games, although not very fun to play showcase me learning a new feature and trying it out for the first time. I\u0026rsquo;ve had the opportunity to participate in several exciting game jams, including:\nüéÆ 101 Hours Jam #2 üéÆ United Game Jam 2020 üéÆ GMTK Game Jam 2020 üéÆ Brackeys Game Jam 2020.2 üéÆ Discord Game Jam #5 üéÆ Ai and Games Jam 2021 üéÆ GMTK Game Jam 2021 üéÆ Global Game Jam 2021 üéÆ Ukie Game Jam 2021 üéÆ Global Game Jam 2022\n101 Hours Jam was my first ever game jam. This is also the game jam where I opened Unity for the first time. I ended up learning Unity and making a game in it within the 101 hours Ai and Games Jam was the first game jam where I learn to work with and design complex Ai behaviours (in Unity) using a custom Finite State Machine framework During Global Game Jam 2021 I decided to make a horror game so I could learn advanced sound design in Unity These experiences have been invaluable in sharpening my problem-solving skills, fostering creativity, and collaborating with like-minded individuals. Game jams have pushed me to think on my feet, iterate rapidly, and create unique and memorable game experiences within a limited timeframe.\nI always look forward to the thrill and excitement of game jams, and I\u0026rsquo;m excited to continue participating in these events to further expand my skills and explore the vast possibilities of game development. It also builds my teamworking skills and understanding the different roles in game development.\nLike all programmers I love spending 10 hours automating something I could have manually done in 10 mintues Connect with me on Linkedin ","date":null,"permalink":"/aboutme/","section":"Home","summary":"Introduction # Hey there!","title":"About Me"},{"content":"","date":null,"permalink":"/categories/","section":"Categories","summary":"","title":"Categories"},{"content":"","date":null,"permalink":"/tags/","section":"Tags","summary":"","title":"Tags"}]